// Copyright 2025 Сергей Савельев (serge@savel.pro)
//
// Лицензировано согласно Лицензии Apache, Версия 2.0 ("Лицензия");
// вы можете использовать этот файл только в соответствии с Лицензией.
// Вы можете найти копию Лицензии по адресу
//
// http://www.apache.org/licenses/LICENSE-2.0.
//
// За исключением случаев, когда это регламентировано существующим
// законодательством, или если это не оговорено в письменном соглашении,
// программное обеспечение, распространяемое на условиях данной Лицензии,
// предоставляется "КАК ЕСТЬ", и любые явные или неявные ГАРАНТИИ ОТВЕРГАЮТСЯ.
// Информацию об основных правах и ограничениях, применяемых к определенному
// языку согласно Лицензии, вы можете найти в данной Лицензии.

#Область Выгрузка

Процедура ВыгрузитьРегламент(Шина) Экспорт
	
	Если КафкаПовтИсп.ЭтоБэкап() И Не КафкаПереопределяемый.РазрешенОбменБэкапов() Тогда
		ТекстСообщения = "Обмен бэкапов запрещен. Выгрузка не будет запущена.";
		КафкаКлиентСервер.СообщитьПользователю(ТекстСообщения);
		ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+Шина.Наименование, УровеньЖурналаРегистрации.Предупреждение, , , ТекстСообщения);
		Возврат;
	КонецЕсли;
		
	Выгрузить(Шина);
	
КонецПроцедуры

Процедура Выгрузить(Шина) Экспорт
	
	Если Не ЗначениеЗаполнено(Шина) Тогда
		ВызватьИсключение "Не заполнена шина. Выгрузка невозможна.";
	КонецЕсли;
	
	ШинаИнфо = ШинаИнфо(Шина);
		
	Если Не ЗначениеЗаполнено(ШинаИнфо.Узел) Тогда
		ВызватьИсключение "Не заполнен узел шины. Выгрузка невозможна.";
	КонецЕсли;
	
	Параллелизм = ИнициализироватьПараллелизм(ШинаИнфо.ОбменКоличествоПотоков);
	
	Обработка = КафкаПереопределяемый.ПолучитьОбработку(ШинаИнфо);
	
	// Установим реквизиты обработки.
	ПотенциальныеРеквизитыОбработки = Новый Структура;
	ПотенциальныеРеквизитыОбработки.Вставить("Шина", ШинаИнфо.Ссылка);
	ПотенциальныеРеквизитыОбработки.Вставить("Узел", ШинаИнфо.Узел);
	УстановитьРеквизитыОбработки(Обработка, ПотенциальныеРеквизитыОбработки);
	
	Заголовки = Новый Соответствие;
	
	// Инициализируем API Кафки.
	Адаптер = КафкаКлиентСервер.Адаптер(ШинаИнфо.Кластер);
	
	ВыгружаемыеОбъектыМетаданных = Обработка.ВыгружаемыеОбъектыМетаданных();
	
	ИнформацияОбОшибке = Неопределено;
	
	Если Не Обработка.ПередВыгрузкойШины(ШинаИнфо, Заголовки, Адаптер) Тогда
		Возврат;
	КонецЕсли;
	
	Попытка
		ВыгрузитьУзел(ШинаИнфо, Обработка, Адаптер, Заголовки, ВыгружаемыеОбъектыМетаданных, Параллелизм);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
	КонецПопытки;
	
	Обработка.ПослеВыгрузкиШины(ШинаИнфо, ИнформацияОбОшибке);
	
	Если ИнформацияОбОшибке <> Неопределено Тогда
		ТекстОшибки = "Выгрузка данных в шину """+ШинаИнфо.Наименование+""" завершилась ошибкой.
		|" + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
КонецПроцедуры

Процедура ВыгрузитьУзел(ШинаИнфо, Обработка, Адаптер, Заголовки, ВыгружаемыеОбъектыМетаданных, Параллелизм)
		
	Изменения = ПолучитьИзменения(ШинаИнфо.Узел);
	
	Если Изменения.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Конфигурация = КонфигурацияШины(ШинаИнфо.Ссылка);
	Если Параллелизм.МаксСтепень < 2 Тогда
		Конфигурация.Вставить("linger.ms", "0");
	КонецЕсли;
	
	// Создадим экземпляр отправителя внутри прокси.
	Producer = Адаптер.ProducerCreate(
		ШинаИнфо.Наименование,
		Конфигурация,
		ШинаИнфо.КлиентТаймаут
	);
	
	Если Producer = Неопределено Тогда
		ВызватьИсключение Адаптер.ОписаниеОшибки;
	КонецЕсли;
	
	Попытка
					
		ПредПорядок = Неопределено;
		
		Для Каждого СтрокаОбъектМетаданных Из ВыгружаемыеОбъектыМетаданных Цикл
					
			РезультатЗапросаИзменения = Изменения.Получить(СтрокаОбъектМетаданных.ПолноеИмя);
			
			Если РезультатЗапросаИзменения = Неопределено Или РезультатЗапросаИзменения.Пустой() Тогда
				Продолжить; // нечего выгружать по текущей таблице
			КонецЕсли;
			
			// Перед началом выгрузки данных нового порядка дожидаемся завершения выгрузки данных старого порядка.
			Если ПредПорядок <> СтрокаОбъектМетаданных.Порядок Тогда
				ДождатьсяОсвобожденияПулаПотоков(Параллелизм, Истина);
			КонецЕсли;
			
			ПредПорядок = СтрокаОбъектМетаданных.Порядок;
						
			ВыгрузитьОбъектМетаданных(ШинаИнфо, Обработка, Адаптер, Producer, СтрокаОбъектМетаданных, РезультатЗапросаИзменения, Заголовки, Параллелизм);
					
		КонецЦикла;
			
		ДождатьсяОсвобожденияПулаПотоков(Параллелизм, Истина);
		
		Адаптер.ProducerRelease(Producer);
		
	Исключение
		
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		
		Адаптер.ProducerRelease(Producer);
		
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

Функция ПолучитьИзменения(Узел)
		
	МассивТекстЗапроса = Новый Массив;
	МассивИменаТаблиц  = Новый Массив;
	
	СоставМетаданных = Узел.Метаданные().Состав;
	
	Для Каждого ЭлементСостава Из СоставМетаданных Цикл
		
		ОбъектМетаданныхИнфо = КафкаПовтИсп.ОписаниеОбъектаМетаданных(ЭлементСостава.Метаданные.ПолноеИмя());
		
		Если ОбъектМетаданныхИнфо.ЭтоКонстанта Тогда
			
			МассивТекстЗапроса.Добавить(
			"ВЫБРАТЬ ПЕРВЫЕ 999999999
			|	ИСТИНА
			|ИЗ
			|	" + ОбъектМетаданныхИнфо.ПолноеИмя + ".Изменения
			|ГДЕ
			|	Узел = &Узел");
			
		ИначеЕсли ОбъектМетаданныхИнфо.ЭтоСсылочныйОбъект Тогда
			
			МассивТекстЗапроса.Добавить(
			"ВЫБРАТЬ ПЕРВЫЕ 999999999
			|	Изменения.Ссылка,
			|	ВЫБОР
			|		КОГДА ОсновнаяТаблица.Ссылка ЕСТЬ NULL 
			|			ТОГДА ИСТИНА
			|		ИНАЧЕ ЛОЖЬ
			|	КОНЕЦ КАК ЭтоУдаление
			|ИЗ
			|	" + ОбъектМетаданныхИнфо.ПолноеИмя + ".Изменения КАК Изменения
			|		ЛЕВОЕ СОЕДИНЕНИЕ " + ОбъектМетаданныхИнфо.ПолноеИмя + " КАК ОсновнаяТаблица
			|		ПО Изменения.Ссылка = ОсновнаяТаблица.Ссылка
			|ГДЕ
			|	Изменения.Узел = &Узел");
			
		Иначе
			
			СтрокаИзмерения = ?(
					ОбъектМетаданныхИнфо.КлючевыеПоля.Количество()=0,
					"ИСТИНА",
					СтрСоединить(ОбъектМетаданныхИнфо.КлючевыеПоля, ", ")
			);
			
			МассивТекстЗапроса.Добавить(
			"ВЫБРАТЬ ПЕРВЫЕ 999999999
			|	" + СтрокаИзмерения + "
			|ИЗ
			|	" + ОбъектМетаданныхИнфо.ПолноеИмя + ".Изменения
			|ГДЕ
			|	Узел = &Узел");
			
		КонецЕсли;
		
		МассивИменаТаблиц.Добавить(ОбъектМетаданныхИнфо.ПолноеИмя);
		
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = СтрСоединить(МассивТекстЗапроса, Символы.ПС+";"+Символы.ПС);
	Запрос.УстановитьПараметр("Узел", Узел);
	
	МассивРезультатыЗапросов = Запрос.ВыполнитьПакет();
		
	Результат = Новый Соответствие;
	
	Для Индекс = 0 По МассивИменаТаблиц.ВГраница() Цикл
		
		ИмяТаблицы = МассивИменаТаблиц[Индекс];
		РезультатЗапроса = МассивРезультатыЗапросов[Индекс];
		
		Если Не РезультатЗапроса.Пустой() Тогда
			Результат.Вставить(ИмяТаблицы, РезультатЗапроса);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура ВыгрузитьОбъектМетаданных(ШинаИнфо, Обработка, Адаптер, Producer, СтрокаОбъектМетаданных, РезультатЗапросаИзменения, ОбщиеЗаголовки, Параллелизм)
	
	Если ЗначениеЗаполнено(СтрокаОбъектМетаданных.РазмерПакета) Тогда
		РазмерПакета = СтрокаОбъектМетаданных.РазмерПакета;
	Иначе
		РазмерПакета = 250;
	КонецЕсли;
	
	Заголовки = Новый Соответствие;
	Для Каждого КЗ Из ОбщиеЗаголовки Цикл
		Заголовки.Вставить(КЗ.Ключ, КЗ.Значение);
	КонецЦикла;
	
	ОбъектМетаданныхИнфо = КафкаПовтИсп.ОписаниеОбъектаМетаданных(СтрокаОбъектМетаданных.ПолноеИмя);
	
	Если Не Обработка.ПередВыгрузкойТаблицы(ОбъектМетаданныхИнфо, Заголовки) Тогда
		Возврат;
	КонецЕсли;
		
	ИзмененияВыборка = РезультатЗапросаИзменения.Выбрать();
	
	ЗаписьЖурналаРегистрации(
			"Обмен данными.Кафка." + ШинаИнфо.Наименование,
			УровеньЖурналаРегистрации.Примечание,
			ШинаИнфо.Узел.Метаданные(),
			ШинаИнфо.Узел,
			"Начата асинхронная отправка " + ИзмененияВыборка.Количество() + " объектов '" + СтрокаОбъектМетаданных.ПолноеИмя + "'."
	);
			
	ТекущийПакет = Неопределено;
						
	// Обходим все измененные/удаленные объекты.
	Пока ИзмененияВыборка.Следующий() Цикл
		
		Если ТекущийПакет = Неопределено Тогда
			
			ТаблицаДанные = Новый ТаблицаЗначений;
			Для Каждого Колонка Из РезультатЗапросаИзменения.Колонки Цикл
				ТаблицаДанные.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
			КонецЦикла;
			
			ТекущийПакет = Новый Структура;
			ТекущийПакет.Вставить("ОбъектМетаданныхИнфо", ОбъектМетаданныхИнфо);
			ТекущийПакет.Вставить("Заголовки", Заголовки);
			ТекущийПакет.Вставить("Данные", ТаблицаДанные);
			ТекущийПакет.Вставить("Размер", 0);
			
		КонецЕсли;					
				
		ЗаполнитьЗначенияСвойств(ТекущийПакет.Данные.Добавить(), ИзмененияВыборка);
		ТекущийПакет.Размер = ТекущийПакет.Размер + 1;
		
		Если ТекущийПакет.Размер >= РазмерПакета Тогда
			ВыгрузитьПакет(ШинаИнфо, Обработка, Producer, Параллелизм, ТекущийПакет);
			ТекущийПакет = Неопределено;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ТекущийПакет <> Неопределено Тогда
		ВыгрузитьПакет(ШинаИнфо, Обработка, Producer, Параллелизм, ТекущийПакет);
		ТекущийПакет = Неопределено;
	КонецЕсли;
		
	ЗаписьЖурналаРегистрации(
			"Обмен данными.Кафка." + ШинаИнфо.Наименование,
			УровеньЖурналаРегистрации.Примечание,
			ШинаИнфо.Узел.Метаданные(),
			ШинаИнфо.Узел,
			"Завершена асинхронная отправка " + ИзмененияВыборка.Количество() + " объектов '" + СтрокаОбъектМетаданных.ПолноеИмя+"'."
	);
			
	Обработка.ПослеВыгрузкиТаблицы(ОбъектМетаданныхИнфо);
	
КонецПроцедуры

Процедура ВыгрузитьПакет(ШинаИнфо, Обработка, Producer, Параллелизм, Пакет)
	
	ДождатьсяОсвобожденияПулаПотоков(Параллелизм);	
		
	Если Параллелизм.МаксСтепень < 2 Тогда
		// Выгрузим пакет в этом же сеансе.
		
		ВыгрузитьПакетЭтотСеанс(ШинаИнфо, Обработка, Producer, Пакет);
		
		Параллелизм.ОбъектыСчетчик = Параллелизм.ОбъектыСчетчик + Пакет.Размер;
		
    Иначе
		// Выгрузим пакет в отдельном фоновом сеансе.
		
		Параллелизм.ПотокиСчетчик = Параллелизм.ПотокиСчетчик + 1;
		
		ПараметрыФЗ = Новый Массив;
		ПараметрыФЗ.Добавить(ШинаИнфо);
		ПараметрыФЗ.Добавить(Producer);
		ПараметрыФЗ.Добавить(Пакет);
		
		ФЗ = ФоновыеЗадания.Выполнить("КафкаСервер.ВыгрузитьПакетОтдельныйСеанс", ПараметрыФЗ, ,
				"Поток выгрузки данных в шину '"+ШинаИнфо.Наименование+"' № "+Параллелизм.ПотокиСчетчик);
				
		Параллелизм.Потоки.Добавить(ФЗ);
		Параллелизм.ПотокиРазмеры.Вставить(ФЗ.УникальныйИдентификатор, Пакет.Размер);
		
	КонецЕсли;
		
КонецПроцедуры

Процедура ВыгрузитьПакетОтдельныйСеанс(ШинаИнфо, Producer, Пакет) Экспорт
	
	Обработка = КафкаПереопределяемый.ПолучитьОбработку(ШинаИнфо);
	
	// Установим реквизиты обработки.
	ПотенциальныеРеквизитыОбработки = Новый Структура;
	ПотенциальныеРеквизитыОбработки.Вставить("Узел", ШинаИнфо.Узел);
	ПотенциальныеРеквизитыОбработки.Вставить("Шина", ШинаИнфо.Ссылка);
	УстановитьРеквизитыОбработки(Обработка, ПотенциальныеРеквизитыОбработки);
	
	ВыгрузитьПакетЭтотСеанс(ШинаИнфо, Обработка, Producer, Пакет);
	
КонецПроцедуры

Процедура ВыгрузитьПакетЭтотСеанс(ШинаИнфо, Обработка, Producer, Пакет)
	
	// Инициализируем соединение с Кафкой.
	Адаптер = КафкаКлиентСервер.Адаптер(ШинаИнфо.Кластер);
	
	ОбъектМетаданныхИнфо = Пакет.ОбъектМетаданныхИнфо;
	
	Обработка.ПередВыгрузкойПакета(ОбъектМетаданныхИнфо, Адаптер);
			
	Для Каждого СтрокаПакета Из Пакет.Данные Цикл
		
		// Скопируем общие заголовки.
		Заголовки = Новый Соответствие;
		Для Каждого КЗ Из Пакет.Заголовки Цикл
			Заголовки.Вставить(КЗ.Ключ, КЗ.Значение);
		КонецЦикла;
		
		// Итерацию выгрузки каждого объекта выполняем в отдельной транзакции.
		// Внутри транзакции только необходимый минимум действий.
		НачатьТранзакцию();
		
		Попытка
		
			// Устанавливаем разделяемую блокировку 
			ПространствоБлокировки = ОбъектМетаданныхИнфо.ПолноеИмя;
			Если ОбъектМетаданныхИнфо.ЭтоПодчиненныйРегистр Или ОбъектМетаданныхИнфо.ЭтоПоследовательность Тогда
				ПространствоБлокировки = ПространствоБлокировки + ".НаборЗаписей";
			КонецЕсли;
			Блокировка = Новый БлокировкаДанных;
			ЭлементБлокировки = Блокировка.Добавить(ПространствоБлокировки);
			Для Каждого Поле Из ОбъектМетаданныхИнфо.КлючевыеПоля Цикл
				ЭлементБлокировки.УстановитьЗначение(Поле, СтрокаПакета[Поле]);
			КонецЦикла;
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
			Блокировка.Заблокировать();
			
			// Читаем объект.
			Если ОбъектМетаданныхИнфо.ЭтоКонстанта Тогда
				
				Объект = Константы[ОбъектМетаданныхИнфо.Имя].СоздатьМенеджерЗначения();
				Объект.Прочитать();
			
			ИначеЕсли ОбъектМетаданныхИнфо.ЭтоСсылочныйОбъект Тогда
				
				Если СтрокаПакета.ЭтоУдаление Тогда
					Объект = Новый УдалениеОбъекта(СтрокаПакета.Ссылка);
				Иначе // Это обычное изменение
					Объект = СтрокаПакета.Ссылка.ПолучитьОбъект();
				КонецЕсли;
					
			Иначе // Это регистр или последовательность
			
				РегистрМенеджер = КафкаПовтИсп.МенеджерОбъектаМетаданных(ОбъектМетаданныхИнфо.ПолноеИмя);
				
				Объект = РегистрМенеджер.СоздатьНаборЗаписей();
				Для Каждого Поле Из ОбъектМетаданныхИнфо.КлючевыеПоля Цикл
					Объект.Отбор[Поле].Установить(СтрокаПакета[Поле]);
				КонецЦикла;
				Объект.Прочитать();
				
			КонецЕсли;
						
			// Разрегистрируем объект, там самым наложив исключительную блокировку
			// на таблицу регистрации изменений.
			ПланыОбмена.УдалитьРегистрациюИзменений(ШинаИнфо.Узел, Объект);
			
			ВыгружатьОбъект = Обработка.ПередВыгрузкойОбъекта(Объект, ОбъектМетаданныхИнфо, Заголовки);
			
			Если ВыгружатьОбъект Тогда
				RecordMetadata = ВыгрузитьОбъект(ШинаИнфо, Обработка, Producer, Адаптер, Объект, ОбъектМетаданныхИнфо, Заголовки);
			КонецЕсли;
						
			ЗафиксироватьТранзакцию();
			
		Исключение
			
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			
			ОтменитьТранзакцию();
			
			ВызватьИсключение
			"Не удалось выполнить отправку объекта "+ПредставлениеОбъекта(Объект, ОбъектМетаданныхИнфо)+".
			|"+ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
			
		КонецПопытки;
		
		Если ВыгружатьОбъект Тогда
			Обработка.ПослеВыгрузкиОбъекта(Объект, ОбъектМетаданныхИнфо, RecordMetadata);
		КонецЕсли;
		
	КонецЦикла;
	
	Обработка.ПослеВыгрузкиПакета(ОбъектМетаданныхИнфо);
	
КонецПроцедуры

Функция ВыгрузитьОбъект(ШинаИнфо, Обработка, Producer, Адаптер, Объект, ОбъектМетаданныхИнфо, Заголовки)
	
	Ключ = Обработка.СообщениеКлюч(Объект, ОбъектМетаданныхИнфо, Заголовки);
	Если Ключ = Неопределено Тогда
		ВызватьИСключение "Не определен ключ сообщения.";
	КонецЕсли;
	
	Значение = Обработка.СообщениеЗначение(Объект, ОбъектМетаданныхИнфо, Заголовки);
	Если Значение = Неопределено Тогда
		ВызватьИСключение "Не определено значение сообщения.";
	КонецЕсли;
	
	Если ШинаИнфо.ТемаЭтоПрефикс Тогда
		ТемаСуффикс = Обработка.СообщениеСуффиксТемы(Объект, ОбъектМетаданныхИнфо, Заголовки);
		Если Не ЗначениеЗаполнено(ТемаСуффикс) Тогда
			ВызватьИсключение "Не заполнен суффикс темы.";
		КонецЕсли;
		Тема = ШинаИнфо.ТемаПрефикс + ТемаСуффикс;
	Иначе
		Тема = ШинаИнфо.Тема;
	КонецЕсли;
	
	HttpЗапрос = Новый HttpЗапрос("producer/send");
	HttpЗапрос.Заголовки.Вставить("Content-Type", "application/octet-stream");
	
	Поток = HttpЗапрос.ПолучитьТелоКакПоток();
	
	ЗаписьДанных = Новый ЗаписьДанных(Поток, КодировкаТекста.UTF8, ПорядокБайтов.BigEndian);
	
	// Версия - 2 байта
	ЗаписьДанных.ЗаписатьЦелое16(1); // 1
	
	// Id отправителя
	Буфер = ПолучитьБуферДвоичныхДанныхИзСтроки(Producer.id);
	ЗаписьДанных.ЗаписатьЦелое32(Буфер.Размер);
	ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
	
	// Токен отправителя
	Буфер = ПолучитьБуферДвоичныхДанныхИзСтроки(Producer.token);
	ЗаписьДанных.ЗаписатьЦелое32(Буфер.Размер);
	ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
	
	// Тема
	Буфер = ПолучитьБуферДвоичныхДанныхИзСтроки(Тема);
	ЗаписьДанных.ЗаписатьЦелое32(Буфер.Размер);
	ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
	
	// Раздел
	Раздел = Неопределено;
	Если Раздел = Неопределено Или Раздел = Null Тогда
		ЗаписьДанных.ЗаписатьБайт(1); // 1
	Иначе
		ЗаписьДанных.ЗаписатьБайт(0); // 0
		ЗаписьДанных.ЗаписатьЦелое32(Раздел);
	КонецЕсли;
	
	// Заголовки
	ЗаписьДанных.ЗаписатьЦелое32(Заголовки.Количество());
	Для Каждого КлючЗначение Из Заголовки Цикл
		
		Буфер = ПолучитьБуферДвоичныхДанныхИзСтроки(КлючЗначение.Ключ);
		ЗаписьДанных.ЗаписатьЦелое32(Буфер.Размер);
		ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
		
		Если КлючЗначение.Значение = Неопределено Или КлючЗначение.Значение = Null Тогда
			ЗаписьДанных.ЗаписатьБайт(1); // 1
		Иначе
			ЗаписьДанных.ЗаписатьБайт(0); // 0
			Буфер = ПолучитьБуферДвоичныхДанныхИзСтроки(КлючЗначение.Значение);
			ЗаписьДанных.ЗаписатьЦелое32(Буфер.Размер);
			ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
		КонецЕсли;
		
	КонецЦикла;
	
	// Ключ
	Если Ключ = Null Тогда
		ЗаписьДанных.ЗаписатьБайт(1); // 1
	Иначе
		ЗаписьДанных.ЗаписатьБайт(0); // 0
		Буфер = СериализоватьКлючВБуферДвоичныхДанных(Ключ, ШинаИнфо.КлючСердес);
		ЗаписьДанных.ЗаписатьЦелое32(Буфер.Размер);
		ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
	КонецЕсли;
	
	//Значение
	Если Значение = Null Тогда
		ЗаписьДанных.ЗаписатьБайт(1); // 1
		ЗаписьДанных.Закрыть();
	Иначе
		ЗаписьДанных.ЗаписатьБайт(0); // 0
		СериализоватьЗначениеВПотокИЗакрытьЗаписьДанных(Значение, ШинаИнфо.ЗначениеСердес, ЗаписьДанных, Поток);
	КонецЕсли;
	
	Поток.Закрыть();
	
	// Отправляем сообщение
	
	HttpСоединение = Адаптер.ПолучитьHttpСоединение();
	
	HttpОтвет = HttpСоединение.ОтправитьДляОбработки(HttpЗапрос);
	HttpОтвет = Адаптер.ПроверитьHttpОтвет(HttpОтвет);	
	
	Если HttpОтвет = Неопределено Тогда
		ВызватьИсключение Строка(Адаптер.КодОтвета) + " " + Адаптер.ОписаниеОшибки;
	КонецЕсли;
	
	// Читаем ответ
	
	Поток = HttpОтвет.ПолучитьТелоКакПоток();
	
	ЧтениеДанных = Новый ЧтениеДанных(Поток, КодировкаТекста.UTF8, ПорядокБайтов.BigEndian);
	
	Версия = ЧтениеДанных.ПрочитатьЦелое16();
	
	Если Версия = 1 Тогда
		
		ТопикДлина = ЧтениеДанных.ПрочитатьЦелое32();
		Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(ТопикДлина);
		Topic = ПолучитьСтрокуИзБуфераДвоичныхДанных(Буфер, КодировкаТекста.UTF8);
		
		Partition = ЧтениеДанных.ПрочитатьЦелое32();
		
		Offset = ЧтениеДанных.ПрочитатьЦелое64();
		
		Timestamp = ЧтениеДанных.ПрочитатьЦелое64();
		
		SerializedKeySize = ЧтениеДанных.ПрочитатьЦелое32();
		
		SerializedValueSize = ЧтениеДанных.ПрочитатьЦелое32();
		
	Иначе
		ВызватьИсключение "Неизвестная версия бинарной сериализации: " + Версия + ".";
	КонецЕсли;
	
	ЧтениеДанных.Закрыть();
	
	Поток.Закрыть();
	
	RecordMetadata = Новый Структура;
	RecordMetadata.Вставить("topic", Topic);
	RecordMetadata.Вставить("partition", Partition);
	RecordMetadata.Вставить("offset", Offset);
	RecordMetadata.Вставить("timestamp", Timestamp);
	RecordMetadata.Вставить("serializedKeySize", SerializedKeySize);
	RecordMetadata.Вставить("serializedValueSize", SerializedValueSize);
	
	Возврат RecordMetadata;
	
КонецФункции

Функция СериализоватьКлючВБуферДвоичныхДанных(Значение, Сердес)
	
	Если Сердес = Перечисления.КафкаСердес.Строка Тогда
				
		Если ТипЗнч(Значение) = Тип("Строка") Тогда
			Возврат ПолучитьБуферДвоичныхДанныхИзСтроки(Значение);
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации ключа.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.ДвоичныеДанные Тогда
				
		ЗначениеТип = ТипЗнч(Значение);
		Если ЗначениеТип = Тип("ДвоичныеДанные") Тогда
			Возврат ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(Значение);
		ИначеЕсли ЗначениеТип = Тип("БуферДвоичныхДанных") Тогда
			Возврат Значение;
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации ключа.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Uuid Тогда
				
		Если ТипЗнч(Значение) = Тип("УникальныйИдентификатор") Тогда
			Возврат ПолучитьБуферДвоичныхДанныхИзСтроки(XmlСтрока(Значение));
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации ключа.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СтруктураJson Тогда
				
		ЗначениеТип = ТипЗнч(Значение);
		Если ЗначениеТип = Тип("Структура") Или ЗначениеТип = Тип("ФиксированнаяСтруктура") Тогда
			
			Поток = Новый ПотокВПамяти;
			ЗаписьJson = Новый ЗаписьJson;
			ЗаписьJson.ОткрытьПоток(Поток, КодировкаТекста.UTF8, Ложь, Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
			КафкаКлиентСервер.JsonСериализовать(Значение, ЗаписьJson);
			ДвоичныеДанные = Поток.ЗакрытьИПолучитьДвоичныеДанные();
			
			Возврат ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(ДвоичныеДанные);
			
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации ключа.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СоответствиеJson Тогда
				
		ЗначениеТип = ТипЗнч(Значение);
		Если ЗначениеТип = Тип("Соответствие") Или ЗначениеТип = Тип("ФиксированноеСоответствие") Тогда
			
			Поток = Новый ПотокВПамяти;
			ЗаписьJson = Новый ЗаписьJSON;
			ЗаписьJson.ОткрытьПоток(Поток, , , Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
			КафкаКлиентСервер.JsonСериализовать(Значение, ЗаписьJson);
			ДвоичныеДанные = Поток.ЗакрытьИПолучитьДвоичныеДанные();
			
			Возврат ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(ДвоичныеДанные);
			
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации ключа.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Xml Тогда
		
		Поток = Новый ПотокВПамяти;
		ЗаписьXml = Новый ЗаписьXML;
		ЗаписьXml.Отступ = Ложь;
		ЗаписьXml.ОткрытьПоток(Поток);
		КафкаКлиентСервер.XmlСериализовать(Значение, ЗаписьXml);
		ДвоичныеДанные = Поток.ЗакрытьИПолучитьДвоичныеДанные();
		
		Возврат ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(ДвоичныеДанные);
		
	Иначе
		ВызватьИсключение "Неожиданнный/неподдерживаемый тип сериализации ключа: """+Сердес+"""."
	КонецЕсли;
	
КонецФункции

Процедура СериализоватьЗначениеВПотокИЗакрытьЗаписьДанных(Значение, Сердес, ЗаписьДанных, Поток)
	
	Если Сердес = Перечисления.КафкаСердес.Строка Тогда
				
		Если ТипЗнч(Значение) = Тип("Строка") Тогда
			
			ЗаписьДанных.ЗаписатьСтроку(Значение);
			ЗаписьДанных.Закрыть();
			
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации значения.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.ДвоичныеДанные Тогда
				
		ЗначениеТип = ТипЗнч(Значение);
		Если ЗначениеТип = Тип("ДвоичныеДанные") Тогда
			
			ЗаписьДанных.Записать(Значение);
			ЗаписьДанных.Закрыть();
			
		ИначеЕсли ЗначениеТип = Тип("БуферДвоичныхДанных") Тогда
			
			ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Значение);
			ЗаписьДанных.Закрыть();
			
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации значения.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Uuid Тогда
				
		Если ТипЗнч(Значение) = Тип("УникальныйИдентификатор") Тогда
			
			ЗаписьДанных.ЗаписатьСтроку(XmlСтрока(Значение));
			ЗаписьДанных.Закрыть();
			
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации значения.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СтруктураJson Тогда
				
		ЗначениеТип = ТипЗнч(Значение);
		Если ЗначениеТип = Тип("Структура") Или ЗначениеТип = Тип("ФиксированнаяСтруктура") Тогда
			
			ЗаписьДанных.Закрыть();
			
			ЗаписьJson = Новый ЗаписьJSON;
			ЗаписьJson.ОткрытьПоток(Поток, КодировкаТекста.UTF8, Ложь, Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
			КафкаКлиентСервер.JsonСериализовать(Значение, ЗаписьJson);
						
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации значения.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СоответствиеJson Тогда
				
		ЗначениеТип = ТипЗнч(Значение);
		Если ЗначениеТип = Тип("Соответствие") Или ЗначениеТип = Тип("ФиксированноеСоответствие") Тогда
			
			ЗаписьДанных.Закрыть();
			
			ЗаписьJson = Новый ЗаписьJSON;
			ЗаписьJson.ОткрытьПоток(Поток, КодировкаТекста.UTF8, Ложь, Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
			КафкаКлиентСервер.JsonСериализовать(Значение, ЗаписьJson);
			
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации значения.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Xml Тогда
		
		ЗаписьДанных.Закрыть();
		
		ЗаписьXml = Новый ЗаписьXML;
		ЗаписьXml.Отступ = Ложь;
		ЗаписьXml.ОткрытьПоток(Поток);
		КафкаКлиентСервер.XmlСериализовать(Значение, ЗаписьXml);
		
	Иначе
		ВызватьИсключение "Неожиданнный/неподдерживаемый тип сериализации значения: """+Сердес+"""."
	КонецЕсли;
	
КонецПроцедуры

#Область ВыгрузкаВспомогательныеФункции

Функция ИнициализироватьПараллелизм(МаксСтепень)
		
	Результат = Новый Структура;
	
	Результат.Вставить("МаксСтепень", МаксСтепень);
	Результат.Вставить("Потоки", Новый Массив);
	Результат.Вставить("ПотокиСчетчик", 0);
	Результат.Вставить("ПотокиРазмеры", Новый Соответствие);
	Результат.Вставить("ОбъектыСчетчик", 0);
	
	Если Результат.МаксСтепень < 1 Тогда
		Результат.МаксСтепень = 1;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Процедура ДождатьсяОсвобожденияПулаПотоков(Параллелизм, ПолноеОсвобождение=Ложь)
	
	Если Не ПолноеОсвобождение И Параллелизм.Потоки.Количество() < Параллелизм.МаксСтепень Тогда
		Возврат;
	КонецЕсли;
	
	ЦелевоеКоличествоПотоков = ?(ПолноеОсвобождение, 0,	Параллелизм.МаксСтепень-1);
	
	Пока Параллелизм.Потоки.Количество() > ЦелевоеКоличествоПотоков Цикл
	
		Параллелизм.Потоки = ФоновыеЗадания.ОжидатьЗавершенияВыполнения(Параллелизм.Потоки, 5);
			
		Колво = Параллелизм.Потоки.Количество();
		Индекс = Колво;
		Пока Индекс > 0 Цикл
			
			Индекс = Индекс - 1;
			ФЗ = Параллелизм.Потоки[Индекс];
			
			Если ФЗ.Состояние = СостояниеФоновогоЗадания.Завершено Тогда
				
				Параллелизм.Потоки.Удалить(Индекс);
				
				Параллелизм.ОбъектыСчетчик = Параллелизм.ОбъектыСчетчик + Параллелизм.ПотокиРазмеры[ФЗ.УникальныйИдентификатор];
				Параллелизм.ПотокиРазмеры.Удалить(ФЗ.УникальныйИдентификатор);
				
			ИначеЕсли ФЗ.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда
				
				ОписаниеОшибки = "Один из потоков завершился ошибкой.";
				Если ФЗ.ИнформацияОбОшибке <> Неопределено Тогда
					ОписаниеОшибки = ОписаниеОшибки + Символы.ПС + ПодробноеПредставлениеОшибки(ФЗ.ИнформацияОбОшибке);
				КонецЕсли;
				
				ВызватьИсключение ОписаниеОшибки;
				
			ИначеЕсли ФЗ.Состояние = СостояниеФоновогоЗадания.Отменено Тогда
				
				ВызватьИсключение "Один из потоков был вручную отменен.";
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ПредставлениеОбъекта(Объект, ОбъектМетаданныхИнфо)
	
	Результат = ОбъектМетаданныхИнфо.ПолноеИмя;
	
	Если Объект <> Неопределено Тогда
		Если ОбъектМетаданныхИнфо.ЭтоСсылочныйОбъект Тогда
			Результат = Результат+" ("""+Строка(Объект)+""")"
		ИначеЕсли ОбъектМетаданныхИнфо.ЭтоПодчиненныйРегистр Тогда
			Результат = Результат+" ("+Строка(Объект.Отбор.Регистратор.Значение)+")"
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область Загрузка

Процедура ЗагрузитьРегламент(Шина) Экспорт
	
	Если КафкаПовтИсп.ЭтоБэкап() И Не КафкаПереопределяемый.РазрешенОбменБэкапов() Тогда
		ТекстСообщения = "Обмен бэкапов запрещен. Загрузка не будет запущена.";
		КафкаКлиентСервер.СообщитьПользователю(ТекстСообщения);
		ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+Шина, УровеньЖурналаРегистрации.Предупреждение, , , ТекстСообщения);
		Возврат;
	КонецЕсли;
	
	Загрузить(Шина);
	
КонецПроцедуры

Процедура Загрузить(Шина) Экспорт
	
	МоментСтарта = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	ШинаИнфо = ШинаИнфо(Шина);
	Если ШинаИнфо = Неопределено Тогда
		ВызватьИсключение "Некорректная шина.";
	КонецЕсли;
	
	Если ШинаИнфо.ОбменДлительностьСеанса <> 0 Тогда
		МоментЗавершения = МоментСтарта + ШинаИнфо.ОбменДлительностьСеанса;
	КонецЕсли;
	
	// Инициализируем API Кафки.
	Адаптер = КафкаКлиентСервер.Адаптер(ШинаИнфо.Кластер);
	
	// Инициализируем параметры получателя.
	ConsumerConfig = КонфигурацияШины(ШинаИнфо.Ссылка);
	Если ConsumerConfig.Получить("group.id") = Неопределено Тогда 
		ConsumerConfig.Вставить("group.id", КафкаПовтИсп.ГруппаПолучателей());
	КонецЕсли;
	
	Consumer = Адаптер.ConsumerCreate(ШинаИнфо.Наименование, ConsumerConfig, ШинаИнфо.КлиентТаймаут);
	Если Consumer = Неопределено Тогда
		ВызватьИсключение Строка(Адаптер.КодОтвета) + " " + Адаптер.ОписаниеОшибки;
	КонецЕсли;
	
	// Получаем перечень всех читаемых разделов.
	Попытка
		Partitions = ПолучитьЧитаемыеРазделы(Адаптер, Consumer, ШинаИнфо.Тема);
		Если Partitions = Неопределено Тогда
			ВызватьИсключение Строка(Адаптер.КодОтвета) + " " + Адаптер.ОписаниеОшибки;
		КонецЕсли;
	Исключение
		Адаптер.ConsumerRelease(Consumer);
		ВызватьИсключение;
	КонецПопытки;
	
	Если Partitions.Количество() = 0 Тогда
		ВызватьИсключение "Не найдены темы Кафки, соответствующие предоставленному отбору.";
	КонецЕсли;
	
	// Вычисляем количество потоков.
	КоличествоПотоков = Макс(ШинаИнфо.ОбменКоличествоПотоков, 1);
	КоличествоПотоков = Мин(КоличествоПотоков, Partitions.Количество());
	
	Если КоличествоПотоков > 1 Тогда
		
		// Освобождаем текущего потребиталя, т.к. в каждом потоке будет свой собственный.
		Адаптер.ConsumerRelease(Consumer);
		
		// Инициализируем массив потоков.
		Потоки = Новый Массив;
		Для НомерПотока = 1 По КоличествоПотоков Цикл
			Поток = Новый Структура;
			Поток.Вставить("Номер", НомерПотока);
			Поток.Вставить("Partitions", Новый Массив);
			Поток.Вставить("ConsumerConfig", ConsumerConfig);
			Потоки.Добавить(Поток);
		КонецЦикла;
			
		// Произвольным (но равномерным) образом распределяем читаемые разделы по потокам.
		ГенераторСлучайныхЧисел = Новый ГенераторСлучайныхЧисел;
		РазделовОсталось = Partitions.Количество();
		Пока РазделовОсталось > 0 Цикл
			Для Каждого Поток Из Потоки Цикл
				Индекс = ГенераторСлучайныхЧисел.СлучайноеЧисло(0, РазделовОсталось-1);
				TopicPartition = Partitions[Индекс];
				Поток.Partitions.Добавить(TopicPartition);
				Partitions.Удалить(Индекс);
				РазделовОсталось = РазделовОсталось - 1;
				Если РазделовОсталось = 0 Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		
		// Определим идентификатор текущего фонового задания для того, чтобы в случае, если текущее задание
		// неожиданно завершится, дочерние задания смогли это определить, и также завершиться.
		ТекущийСеансИБ = ПолучитьТекущийСеансИнформационнойБазы();
		ТекущееФЗ = ТекущийСеансИБ.ПолучитьФоновоеЗадание();
		Если ТекущееФЗ <> Неопределено Тогда
			ИдентификаторТекущегоФЗ = ТекущееФЗ.УникальныйИдентификатор;
		Иначе
			ИдентификаторТекущегоФЗ = Неопределено;
		КонецЕсли;
		
		МассивЗаданий = Новый Массив;
		
		// Несколько потоков - запустим каждый в отдельном сеансе.
		Для Каждого Поток Из Потоки Цикл
						
			ЗаданиеПараметры = Новый Массив;
			ЗаданиеПараметры.Добавить(ШинаИнфо);
			ЗаданиеПараметры.Добавить(Поток);
			ЗаданиеПараметры.Добавить(МоментЗавершения);
			ЗаданиеПараметры.Добавить(ИдентификаторТекущегоФЗ);
			
			ЗаданиеКлюч = "КафкаСервер.ЗагрузитьРазделы_"
					+ Строка(ШинаИнфо.Ссылка.УникальныйИдентификатор()) + "_"
					+ Формат(Поток.Номер, "ЧЦ=3; ЧДЦ=0; ЧН=000");
					
			ЗаданиеНаименование = "Кафка загрузка " + ШинаИнфо.Наименование + " (" + Поток.Номер + ")";
					
			Задание = ФоновыеЗадания.Выполнить("КафкаСервер.ЗагрузитьРазделы", ЗаданиеПараметры, ЗаданиеКлюч, ЗаданиеНаименование);
			
			МассивЗаданий.Добавить(Задание);
			
		КонецЦикла;
		
		Ошибки = Новый Массив;
		
		// Ожидаем завершения потоков.
		Пока МассивЗаданий.Количество() > 0 Цикл
		
			МассивЗаданий = ФоновыеЗадания.ОжидатьЗавершенияВыполнения(МассивЗаданий, 5);
			
			Индекс = МассивЗаданий.Количество();
			Пока Индекс > 0 Цикл
				
				Индекс = Индекс - 1;
				Задание = МассивЗаданий[Индекс];
				
				Если Задание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
					Продолжить;
				КонецЕсли;
				
				МассивЗаданий.Удалить(Индекс);
				
				Если Задание.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда
					Ошибки.Добавить(Задание.ИнформацияОбОшибке);
				ИначеЕсли Задание.Состояние = СостояниеФоновогоЗадания.Отменено Тогда
					ОписаниеОшибки = "Один из потоков был вручную отменен.";
					ЗаписьЖурналаРегистрации(
							"Обмен данными.Кафка."+ШинаИнфо.Наименование,
							УровеньЖурналаРегистрации.Предупреждение,
							ШинаИнфо.Ссылка.Метаданные(),
							ШинаИнфо.Ссылка,
							ОписаниеОшибки);
				КонецЕсли;
						
			КонецЦикла;
			
		КонецЦикла;
		
		// Обработаем ошибки.
		Если Ошибки.Количество() > 0 Тогда
			МассивОписаниеОшибки = Новый Массив;
			МассивОписаниеОшибки.Добавить("Один или несколько потоков загрузки завершились ошибками.");
			Для Каждого ИнформацияОбОшибке Из Ошибки Цикл
				Если ИнформацияОбОшибке = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				МассивОписаниеОшибки.Добавить(Символы.ПС);
				МассивОписаниеОшибки.Добавить(Символы.ПС);
				МассивОписаниеОшибки.Добавить(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
			КонецЦикла;
			ВызватьИсключение СтрСоединить(МассивОписаниеОшибки);
		КонецЕсли;
		
	Иначе
		
		Поток = Новый Структура;
		Поток.Вставить("Номер", 1);
		Поток.Вставить("Partitions", Partitions);
		Поток.Вставить("Consumer", Consumer);
		Поток.Вставить("Адаптер", Адаптер);
		
		Попытка
			ЗагрузитьРазделы(ШинаИнфо, Поток, МоментЗавершения);
			Адаптер.ConsumerRelease(Consumer);
		Исключение
			Адаптер.ConsumerRelease(Consumer);
			ВызватьИсключение;
		КонецПопытки;

	КонецЕсли;
			
КонецПроцедуры

Процедура ЗагрузитьРазделы(ШинаИнфо, Параметры, МоментЗавершения, ИдентификаторРодительскогоФЗ=Неопределено) Экспорт
	
	// Инициализируем API Кафки.
	Адаптер = Неопределено;
	Если Не Параметры.Свойство("Адаптер", Адаптер) Тогда 
		Адаптер = КафкаКлиентСервер.Адаптер(ШинаИнфо.Кластер);
	КонецЕсли;
	
	// Инициализируем обработку загрузки данных.
	Обработка = КафкаПереопределяемый.ПолучитьОбработку(ШинаИнфо);
	Если Обработка = Неопределено Тогда
		ВызватьИсключение "Не удалось инициализировать обработку обмена для шины """+ШинаИнфо.Наименование+""".";
	КонецЕсли;
	
	// Установим реквизиты обработки.
	ПотенциальныеРеквизитыОбработки = Новый Структура;
	ПотенциальныеРеквизитыОбработки.Вставить("Узел", ШинаИнфо.Узел);
	ПотенциальныеРеквизитыОбработки.Вставить("Шина", ШинаИнфо.Ссылка);
	УстановитьРеквизитыОбработки(Обработка, ПотенциальныеРеквизитыОбработки);
	
	// Если по каким-то (или всем) разделам загрузка запрещена, удаляем разделы из массива.
	Индекс = Параметры.Partitions.Количество();
	Пока Индекс > 0 Цикл
		Индекс = Индекс - 1;
		TopicPartition = Параметры.Partitions[Индекс];
		Если Не Обработка.ПередЗагрузкойРаздела(TopicPartition.Topic, TopicPartition.Partition, Адаптер) Тогда
			Параметры.Partitions.Удалить(Индекс);
		КонецЕсли;
	КонецЦикла;
	
	Если Параметры.Partitions.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
		
	Consumer = Неопределено;
	Если Параметры.Свойство("Consumer", Consumer) Тогда
		
		ЗагрузитьРазделы_(ШинаИнфо, Обработка, Адаптер, Consumer, Параметры.Partitions, МоментЗавершения, ИдентификаторРодительскогоФЗ);
		
	Иначе
		
		// Создаем экземпляр получателя внутри прокси, который будет читать сообщения для нас.
		Consumer = Адаптер.ConsumerCreate(
				ШинаИнфо.Наименование+" ("+Параметры.Номер+")",
				Параметры.ConsumerConfig,
				ШинаИнфо.КлиентТаймаут
		);
		Если Consumer = Неопределено Тогда
			ВызватьИсключение Строка(Адаптер.КодОтвета) + " " + Адаптер.ОписаниеОшибки;
		КонецЕсли;
		
		Попытка
			ЗагрузитьРазделы_(ШинаИнфо, Обработка, Адаптер, Consumer, Параметры.Partitions, МоментЗавершения, ИдентификаторРодительскогоФЗ);
			Адаптер.ConsumerRelease(Consumer);
		Исключение
			Адаптер.ConsumerRelease(Consumer);
			ВызватьИсключение;
		КонецПопытки;
		
	КонецЕсли;
			
КонецПроцедуры

Процедура ЗагрузитьРазделы_(ШинаИнфо, Обработка, Адаптер, Consumer, Partitions, МоментЗавершения, ИдентификаторРодительскогоФЗ)
		
	СостоянияЧтения = ПолучитьСостоянияЧтения(ШинаИнфо, Адаптер, Consumer, Partitions);
		
	Assignment = Новый Массив;
	
	Для Каждого topicPartition Из Partitions Цикл
		
		СостояниеЧтенияРаздела = СостоянияЧтения[topicPartition.topic][topicPartition.partition];
		
		СостояниеЧтенияРаздела.Вставить("ПолученоСообщенийПослеПоследнейФиксации", 0);
		
		Если ШинаИнфо.ПриемВРеальномВремени Или СостояниеЧтенияРаздела.ТекущееСмещение < СостояниеЧтенияРаздела.КонечноеСмещение Тогда
			Assignment.Добавить(topicPartition);
		КонецЕсли;
		
	КонецЦикла;
		
	Если Assignment.Количество() > 0 Тогда
		
		Успех = Адаптер.ConsumerAssign(Consumer, Assignment);
		Если Успех <> Истина Тогда
			ВызватьИсключение Строка(Адаптер.КодОтвета) + " " + Адаптер.ОписаниеОшибки;
		КонецЕсли;
			
		Для Каждого topicPartition Из Assignment Цикл
			
			СостояниеЧтенияРаздела = СостоянияЧтения[topicPartition.topic][topicPartition.partition];
			
			Успех = Адаптер.ConsumerSeek(Consumer, topicPartition.topic, topicPartition.partition, СостояниеЧтенияРаздела.ТекущееСмещение);
			Если Успех <> Истина Тогда
				ВызватьИсключение Строка(Адаптер.КодОтвета) + " " + Адаптер.ОписаниеОшибки;
			КонецЕсли;
					
			ЗаписьЖурналаРегистрации(
					"Обмен данными.Кафка."+ШинаИнфо.Наименование,
					УровеньЖурналаРегистрации.Информация,
					,
					topicPartition.topic+":"+Формат(topicPartition.partition, "ЧН=0; ЧГ=0"),
					"Начато чтение раздела. Начальная позиция: "+Формат(СостояниеЧтенияРаздела.ТекущееСмещение, "ЧН=0")+"."
			);
			
		КонецЦикла;
			
		ИмяПроцедурыЗагрузки = "Обработка." + ШинаИнфо.ПриемПроцедура + "(Сообщение)";
		
		ОсталосьРазделов = Assignment.Количество();
			
		Пока ОсталосьРазделов > 0 Цикл
			
			Сообщения = ПолучитьСообщения(ШинаИнфо, Адаптер, Consumer);
			
			Если Не ШинаИнфо.ПриемВРеальномВремени И Сообщения.Количество() = 0 Тогда
				Прервать;
			КонецЕсли;
			
			Для Каждого Сообщение Из Сообщения Цикл
				
				Попытка				
					Выполнить(ИмяПроцедурыЗагрузки);
				Исключение
					ЗафиксироватьПозицииЧтения(ШинаИнфо, СостоянияЧтения);
					ВызватьИсключение;
				КонецПопытки;
							
				СостояниеЧтенияРаздела = СостоянияЧтения[Сообщение.Тема][Сообщение.Раздел];
				
				СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации = СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации + 1;			
				
				ПредыдущееСмещение = СостояниеЧтенияРаздела.ТекущееСмещение;
				СостояниеЧтенияРаздела.ТекущееСмещение = Сообщение.Смещение + 1;
				
				Если Не ШинаИнфо.ПриемВРеальномВремени
				И ПредыдущееСмещение < СостояниеЧтенияРаздела.КонечноеСмещение
				И СостояниеЧтенияРаздела.ТекущееСмещение >= СостояниеЧтенияРаздела.КонечноеСмещение Тогда
					ОсталосьРазделов = ОсталосьРазделов - 1;
				КонецЕсли;
				
			КонецЦикла;
						
			ЗафиксироватьПозицииЧтения(ШинаИнфо, СостоянияЧтения);
			
			Если НеобходимоЗавершитьОперацию(МоментЗавершения, ИдентификаторРодительскогоФЗ) Тогда
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		Для Каждого topicPartition Из Assignment Цикл
			
			СостояниеЧтенияРаздела = СостоянияЧтения[topicPartition.topic][topicPartition.partition];
							
			ЗаписьЖурналаРегистрации(
					"Обмен данными.Кафка."+ШинаИнфо.Наименование,
					УровеньЖурналаРегистрации.Информация,
					,
					topicPartition.topic+":"+Формат(topicPartition.partition, "ЧН=0; ЧГ=0"),
					"Завершено чтение раздела. Конечная позиция: "+Формат(СостояниеЧтенияРаздела.ТекущееСмещение, "ЧН=0")+"."
			);
			
			РегистрыСведений.КафкаПозиции.УдалитьСтарые(ШинаИнфо.Кластер, topicPartition.topic, topicPartition.partition);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Для Каждого КлючЗначениеТема Из СостоянияЧтения Цикл
		Для Каждого КлючЗначениеРаздел Из КлючЗначениеТема.Значение Цикл
			СостояниеЧтенияРаздела = КлючЗначениеРаздел.Значение;
			Обработка.ПослеЗагрузкиРаздела(КлючЗначениеТема.Ключ, КлючЗначениеРаздел.Ключ, СостояниеЧтенияРаздела.ТекущееСмещение);
		КонецЦикла;
	КонецЦикла;
		
КонецПроцедуры

Функция ПолучитьСостоянияЧтения(ШинаИнфо, Адаптер, Consumer, Partitions)
	
	Попытка
		СостоянияЧтения = ПолучитьДеревоГраничныхСмещений(Адаптер, Consumer, Partitions);
	Исключение
		ВызватьИсключение Строка(Адаптер.КодОтвета) + " " + Адаптер.ОписаниеОшибки;
	КонецПопытки;
			
	Для Каждого КлючЗначениеТема Из СостоянияЧтения Цикл
		
		Тема = КлючЗначениеТема.Ключ;
				
		Для Каждого КлючЗначениеРаздел Из КлючЗначениеТема.Значение Цикл
			
			Раздел = КлючЗначениеРаздел.Ключ;
			СостояниеЧтенияРаздела = КлючЗначениеРаздел.Значение;
			
			ТекущееСмещение = РегистрыСведений.КафкаПозиции.ПолучитьПозицию(ШинаИнфо.Кластер, Тема, Раздел);
			
			// Проверка корректности текущей позиции
			Если ТекущееСмещение < СостояниеЧтенияРаздела.НачальноеСмещение Тогда
				
				ЗаписьЖурналаРегистрации(
						"Обмен данными.Кафка."+ШинаИнфо.Наименование,
						УровеньЖурналаРегистрации.Предупреждение,
						,
						Тема+":"+Формат(Раздел, "ЧН=0; ЧГ=0"),
						"Начальная позиция раздела ("+Формат(СостояниеЧтенияРаздела.НачальноеСмещение, "ЧН=0")+") больше текущей ("+Формат(ТекущееСмещение, "ЧН=0")+"). Текущая позиция будет скорректирована."
				);
				
				ТекущееСмещение = СостояниеЧтенияРаздела.НачальноеСмещение;
				
			ИначеЕсли ТекущееСмещение > СостояниеЧтенияРаздела.КонечноеСмещение Тогда
				
				ЗаписьЖурналаРегистрации(
						"Обмен данными.Кафка."+ШинаИнфо.Наименование,
						УровеньЖурналаРегистрации.Предупреждение,
						,
						Тема+":"+Формат(Раздел, "ЧН=0; ЧГ=0"),
						"Конечная позиция раздела ("+Формат(СостояниеЧтенияРаздела.КонечноеСмещение, "ЧН=0")+") меньше текущей ("+Формат(ТекущееСмещение, "ЧН=0")+"). Текущая позиция будет скорректирована."
				);
				
				ТекущееСмещение = СостояниеЧтенияРаздела.КонечноеСмещение;
				
			КонецЕсли;
			
			СостояниеЧтенияРаздела.Вставить("ТекущееСмещение", ТекущееСмещение);
			
		КонецЦикла;
				
	КонецЦикла;
		
	Возврат СостоянияЧтения;
	
КонецФункции

Функция ПолучитьСообщения(ШинаИнфо, Адаптер, Consumer)
		
	HttpОтвет = Адаптер.ConsumerPollRaw(Consumer, ШинаИнфо.ПриемТаймаутОжидания, "application/octet-stream");
	
	Если HttpОтвет = Неопределено Тогда
		ВызватьИсключение Строка(Адаптер.КодОтвета) + " " + Адаптер.ОписаниеОшибки;
	КонецЕсли;
	
	Результат = Новый Массив;
	
	Поток = HttpОтвет.ПолучитьТелоКакПоток();
	
	ЧтениеДанных = Новый ЧтениеДанных(Поток, КодировкаТекста.UTF8, ПорядокБайтов.BigEndian);
	
	Версия = ЧтениеДанных.ПрочитатьЦелое16();
	
	Если Версия = 1 Тогда
		
		КоличествоСообщений = ЧтениеДанных.ПрочитатьЦелое32();
		
		Для НомерСообщения = 1 По КоличествоСообщений Цикл
						
			Длина = ЧтениеДанных.ПрочитатьЦелое32();
			Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Длина);
			Тема = ПолучитьСтрокуИзБуфераДвоичныхДанных(Буфер, КодировкаТекста.UTF8);
			
			Раздел = ЧтениеДанных.ПрочитатьЦелое32();
			
			Смещение = ЧтениеДанных.ПрочитатьЦелое64();
			
			ОтметкаВремени = ЧтениеДанных.ПрочитатьЦелое64();
			
			КоличествоЗаголовков = ЧтениеДанных.ПрочитатьЦелое32();
			Заголовки = Новый Соответствие;
			
			Для НомерЗаголовка = 1 По КоличествоЗаголовков Цикл
				
				Длина = ЧтениеДанных.ПрочитатьЦелое32();
				Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Длина);
				ЗаголовокИмя = ПолучитьСтрокуИзБуфераДвоичныхДанных(Буфер, КодировкаТекста.UTF8);
				
				ЗаголовокЭтоNull = ЧтениеДанных.ПрочитатьБайт();
				Если ЗаголовокЭтоNull Тогда
					ЗаголовокЗначение = Null;
				Иначе
					Длина = ЧтениеДанных.ПрочитатьЦелое32();
					Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Длина);
					ЗаголовокЗначение = ПолучитьСтрокуИзБуфераДвоичныхДанных(Буфер, КодировкаТекста.UTF8);
				КонецЕсли;
				
				Заголовки.Вставить(ЗаголовокИмя, ЗаголовокЗначение);
				
			КонецЦикла;
			
			Ключ = ДесериализоватьЗначение(ЧтениеДанных, ШинаИнфо.КлючСердес);
			
			Значение = ДесериализоватьЗначение(ЧтениеДанных, ШинаИнфо.ЗначениеСердес);
			
			Сообщение = Новый Структура;
			Сообщение.Вставить("Тема", Тема);
			Сообщение.Вставить("Раздел", Раздел);
			Сообщение.Вставить("Смещение", Смещение);
			Сообщение.Вставить("ОтметкаВремени", ОтметкаВремени);
			Сообщение.Вставить("Заголовки", Заголовки);
			Сообщение.Вставить("Ключ", Ключ);
			Сообщение.Вставить("Значение", Значение);
			
			Результат.Добавить(Сообщение);
			
		КонецЦикла;
		
	Иначе
		ВызватьИсключение "Неизвестная версия бинарной сериализации: " + Версия + ".";
	КонецЕсли;
	
	ЧтениеДанных.Закрыть();
	
	Поток.Закрыть();
	
	Возврат Результат;
	
КонецФункции

Функция ДесериализоватьЗначение(ЧтениеДанных, Сердес)
	
	ЭтоNull = ЧтениеДанных.ПрочитатьБайт();
	
	Если ЭтоNull Тогда
		
		Возврат Null;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Null Тогда
		
		ВызватьИсключение "Некорректный тип исходных данных. Ожидается NULL, но получено другое значение.";
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Игнорировать Тогда
		
		Длина = ЧтениеДанных.ПрочитатьЦелое32();
		ЧтениеДанных.Пропустить(Длина);
		
		Возврат Неопределено;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Строка Тогда
		
		Длина = ЧтениеДанных.ПрочитатьЦелое32();
		Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Длина);
		Возврат ПолучитьСтрокуИзБуфераДвоичныхДанных(Буфер, КодировкаТекста.UTF8);
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Uuid Тогда
		
		Длина = ЧтениеДанных.ПрочитатьЦелое32();
		Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Длина);
		UuidСтрокой = ПолучитьСтрокуИзБуфераДвоичныхДанных(Буфер, КодировкаТекста.UTF8);
		Возврат XmlЗначение(Тип("УникальныйИдентификатор"), UuidСтрокой);
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.ДвоичныеДанные Тогда
		
		КлючДлина = ЧтениеДанных.ПрочитатьЦелое32();
		РезультатЧтенияДанных = ЧтениеДанных.Прочитать(КлючДлина);
		Возврат РезультатЧтенияДанных.ПолучитьДвоичныеДанные();
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СтруктураJson Тогда
		
		КлючДлина = ЧтениеДанных.ПрочитатьЦелое32();
		РезультатЧтенияДанных = ЧтениеДанных.Прочитать(КлючДлина);
		Поток = РезультатЧтенияДанных.ОткрытьПотокДляЧтения();
		
		ЧтениеJson = Новый ЧтениеJSON;
		ЧтениеJson.ОткрытьПоток(Поток, КодировкаТекста.UTF8);
		Значение = КафкаКлиентСервер.JsonДесериализовать(ЧтениеJson, Ложь);
		
		Поток.Закрыть();
		
		Возврат Значение;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СоответствиеJson Тогда
		
		КлючДлина = ЧтениеДанных.ПрочитатьЦелое32();
		РезультатЧтенияДанных = ЧтениеДанных.Прочитать(КлючДлина);
		Поток = РезультатЧтенияДанных.ОткрытьПотокДляЧтения();
		
		ЧтениеJson = Новый ЧтениеJSON;
		ЧтениеJson.ОткрытьПоток(Поток, КодировкаТекста.UTF8);
		Значение = КафкаКлиентСервер.JsonДесериализовать(ЧтениеJson, Истина);
		
		Поток.Закрыть();
		
		Возврат Значение;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Xml Тогда
		
		КлючДлина = ЧтениеДанных.ПрочитатьЦелое32();
		РезультатЧтенияДанных = ЧтениеДанных.Прочитать(КлючДлина);
		Поток = РезультатЧтенияДанных.ОткрытьПотокДляЧтения();
		
		ЧтениеXml = Новый ЧтениеXML;
		ЧтениеXml.ОткрытьПоток(Поток, , , КодировкаТекста.UTF8);
		Значение = КафкаКлиентСервер.XmlДесериализовать(ЧтениеXml);
		
		Поток.Закрыть();
		
		Возврат Значение;
		
	Иначе
		ВызватьИсключение "Неожиданнный/неподдерживаемый тип сериализации значения: """+Сердес+"""."
	КонецЕсли;
	
КонецФункции

Процедура ЗафиксироватьПозицииЧтения(ШинаИнфо, СостоянияЧтения)
	
	Если ТранзакцияАктивна() Тогда
		ВызватьИсключение "Во время фиксации позиции чтения транзакция не должна быть активна.";
	КонецЕсли;
	
	Для Каждого КлючЗначениеТема Из СостоянияЧтения Цикл
		
		Тема = КлючЗначениеТема.Ключ;
		
		Для Каждого КлючЗначениеРаздел Из КлючЗначениеТема.Значение Цикл
			
			Раздел = КлючЗначениеРаздел.Ключ;
			СостояниеЧтенияРаздела = КлючЗначениеРаздел.Значение;
			
			Если СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации = 0 Тогда
				Продолжить;
			КонецЕсли;
						
			РегистрыСведений.КафкаПозиции.УстановитьПозицию(ШинаИнфо.Кластер, Тема, Раздел, СостояниеЧтенияРаздела.ТекущееСмещение);
			
			СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации = 0;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

Функция НеобходимоЗавершитьОперацию(МоментЗавершения, ИдентификаторРодительскогоФЗ)
	
	// Проверка истечения максимальной длительности сеанса.
	Если МоментЗавершения <> Неопределено И ТекущаяУниверсальнаяДатаВМиллисекундах() >= МоментЗавершения Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Проверка активности родительского фонового задания.
	Если ИдентификаторРодительскогоФЗ <> Неопределено Тогда
		РодительскоеФЗ = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(ИдентификаторРодительскогоФЗ);
		Если РодительскоеФЗ = Неопределено Или РодительскоеФЗ.Состояние <> СостояниеФоновогоЗадания.Активно Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	// Проверка необходимости завершения соединения из-за выключенного рабочего процесса.
	НеобходимостьЗавершенияСоединения = НеобходимостьЗавершенияСоединения();
	Если НеобходимостьЗавершенияСоединения.НеобходимоЗавершить Тогда
		Возврат Истина;
	КонецЕсли;
				
	Возврат Ложь;
	
КонецФункции

#КонецОбласти

#Область СлужебныеФункции

Функция КонфигурацияБазовая(Кластер) Экспорт
	
	КластерСсылка = ?(Кластер=Неопределено, Справочники.КафкаКластеры.ПоУмолчанию, Кластер);
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Кластеры.КафкаСерверы КАК Серверы,
	|	Кластеры.КафкаПротоколБезопасности КАК ПротоколБезопасности,
	|	Кластеры.КафкаМеханизмSASL КАК МеханизмSASL,
	|	Кластеры.КафкаПользователь КАК Пользователь,
	|	Кластеры.КафкаПользовательУстановлен КАК ПользовательУстановлен,
	|	Кластеры.КафкаПароль КАК Пароль
	|ИЗ
	|	Справочник.КафкаКластеры КАК Кластеры
	|ГДЕ
	|	Кластеры.Ссылка = &Кластер");
	Запрос.УстановитьПараметр("Кластер", КластерСсылка);
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		ВызватьИсключение "Передан некорректный параметр.";
	КонецЕсли;
	
	КластерРеквизиты = РезультатЗапроса.Выгрузить()[0];
	
	Результат = Новый Соответствие;
	Результат.Вставить("bootstrap.servers", КластерРеквизиты.Серверы);
	Результат.Вставить("security.protocol", КластерРеквизиты.ПротоколБезопасности);
	
	Если КластерРеквизиты.ПротоколБезопасности = "PLAINTEXT" Тогда
		
	ИначеЕсли КластерРеквизиты.ПротоколБезопасности = "SASL_PLAINTEXT" Или КластерРеквизиты.ПротоколБезопасности = "SASL_SSL" Тогда
				
		Результат.Вставить("sasl.mechanism", КластерРеквизиты.МеханизмSASL);
		
		Если КластерРеквизиты.МеханизмSASL = "PLAIN" Тогда
			ClassName = "org.apache.kafka.common.security.plain.PlainLoginModule";
		ИначеЕсли КластерРеквизиты.МеханизмSASL = "SCRAM-SHA-256" Или КластерРеквизиты.МеханизмSASL = "SCRAM-SHA-512" Тогда
			ClassName = "org.apache.kafka.common.security.scram.ScramLoginModule";
		Иначе
			ВызватьИсключение "Неожиданное значение механизма SASL: """ + КластерРеквизиты.МеханизмSASL + """.";
		КонецЕсли;
		
		Если КластерРеквизиты.ПользовательУстановлен Тогда
			SaslUsername = КластерРеквизиты.Пользователь;
		Иначе
			SaslUsername = КафкаПереопределяемый.ПользовательПоУмолчанию();
		КонецЕсли;
		SaslUsername = СтрЗаменить(SaslUsername, "\", "\\");
		SaslUsername = СтрЗаменить(SaslUsername, """", "\""");
		
		SaslPassword = КластерРеквизиты.Пароль;
		SaslPassword = СтрЗаменить(SaslPassword, "\", "\\");
		SaslPassword = СтрЗаменить(SaslPassword, """", "\""");
		
		Результат.Вставить("sasl.jaas.config", ClassName + " required username=""" + SaslUsername + """ password=""" + SaslPassword + """;");
		
	ИначеЕсли КластерРеквизиты.ПротоколБезопасности = "SSL" Тогда
		
	Иначе
		ВызватьИсключение "Неожиданное значение протокола безопасности: """ + КластерРеквизиты.ПротоколБезопасности + """.";
	КонецЕсли;
		
	Возврат Результат;
			
КонецФункции

Функция КонфигурацияОтправителя(Кластер=Неопределено) Экспорт
	
	КластерСсылка = ?(Кластер=Неопределено, Справочники.КафкаКластеры.ПоУмолчанию, Кластер);
	
	Конфигурация = КонфигурацияБазовая(КластерСсылка);
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	КафкаКластеры.ПроксиТаймаут КАК ПроксиТаймаут
	|ИЗ
	|	Справочник.КафкаКластеры КАК КафкаКластеры
	|ГДЕ
	|	КафкаКластеры.Ссылка = &Кластер
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Конфигурация.Параметр КАК Параметр,
	|	Конфигурация.Значение КАК Значение
	|ИЗ
	|	Справочник.КафкаКластеры.КафкаКонфигурацияОтправителя КАК Конфигурация
	|ГДЕ
	|	Конфигурация.Ссылка = &Кластер");
	Запрос.УстановитьПараметр("Кластер", КластерСсылка);
	РезультатыЗапросов = Запрос.ВыполнитьПакет();
	
	Выборка = РезультатыЗапросов[0].Выбрать();
	Выборка.Следующий();	
	Конфигурация.Вставить("delivery.timeout.ms", Выборка.ПроксиТаймаут*1000-1000);
	
	Выборка = РезультатыЗапросов[1].Выбрать();
	Пока Выборка.Следующий() Цикл
		Конфигурация.Вставить(Выборка.Параметр, Выборка.Значение);
	КонецЦикла;
	
	Возврат Конфигурация;
			
КонецФункции

Функция КонфигурацияПолучателя(Кластер=Неопределено) Экспорт
	
	КластерСсылка = ?(Кластер=Неопределено, Справочники.КафкаКластеры.ПоУмолчанию, Кластер);
	
	Результат = КонфигурацияБазовая(КластерСсылка);
	
	Результат.Вставить("group.id", КафкаПереопределяемый.ГруппаПолучателей());
	Результат.Вставить("auto.offset.reset", "earliest");
	Результат.Вставить("enable.auto.commit", "false");
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Конфигурация.Параметр КАК Параметр,
	|	Конфигурация.Значение КАК Значение
	|ИЗ
	|	Справочник.КафкаКластеры.КафкаКонфигурацияПолучателя КАК Конфигурация
	|ГДЕ
	|	Конфигурация.Ссылка = &Кластер");
	Запрос.УстановитьПараметр("Кластер", КластерСсылка);
	РезультатЗапроса = Запрос.Выполнить();
			
	Выборка = РезультатЗапроса.Выбрать();
	Пока Выборка.Следующий() Цикл
		Результат.Вставить(Выборка.Параметр, Выборка.Значение);
	КонецЦикла;
	
	Возврат Результат;
			
КонецФункции

Функция КонфигурацияШины(Шина) Экспорт
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Шины.Ссылка КАК Ссылка,
	|	Шины.Кластер КАК Кластер,
	|	Шины.ОбменНаправление КАК ОбменНаправление
	|ИЗ
	|	Справочник.КафкаШины КАК Шины
	|ГДЕ
	|	Шины.Ссылка = &Шина
	|	И НЕ Шины.ЭтоГруппа
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Конфигурация.Параметр КАК Параметр,
	|	Конфигурация.Значение КАК Значение
	|ИЗ
	|	Справочник.КафкаШины.КафкаКонфигурация КАК Конфигурация
	|ГДЕ
	|	Конфигурация.Ссылка = &Шина");
	Запрос.УстановитьПараметр("Шина", Шина);
	РезультатЗапроса = Запрос.ВыполнитьПакет();
	
	Если РезультатЗапроса[0].Пустой() Тогда
		ВызватьИсключение "Передан некорректный параметр.";
	КонецЕсли;
	
	ШинаРеквизиты = РезультатЗапроса[0].Выгрузить()[0];
	
	Если ШинаРеквизиты.ОбменНаправление = Перечисления.КафкаНаправленияОбмена.Выгрузка Тогда
		Результат = КонфигурацияОтправителя(ШинаРеквизиты.Кластер);
	ИначеЕсли ШинаРеквизиты.ОбменНаправление = Перечисления.КафкаНаправленияОбмена.Загрузка Тогда
		Результат = КонфигурацияПолучателя(ШинаРеквизиты.Кластер);
	Иначе
		ВызватьИсключение "Неожиданное направление обмена: """+ШинаРеквизиты.ОбменНаправление+""".";
	КонецЕсли;
			
	ТЗ = РезультатЗапроса[1].Выгрузить();
	Для Каждого С Из ТЗ Цикл
		Результат.Вставить(С.Параметр, С.Значение);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура УстановитьРеквизитыОбработки(Обработка, ПотенциальныеРеквизиты)
	
	ОбработкаМетаданные = Обработка.Метаданные();
	
	Для Каждого КЗ Из ПотенциальныеРеквизиты Цикл
		
		ОбработкаРеквизит = ОбработкаМетаданные.Реквизиты.Найти(КЗ.Ключ);
		
		Если ОбработкаРеквизит <> Неопределено Тогда
			
			ЗначениеПравое = КЗ.Значение;
			Обработка[КЗ.Ключ] = ЗначениеПравое;
			ЗначениеЛевое = Обработка[КЗ.Ключ]; 
			
			Если Не ЗначениеЗаполнено(ЗначениеЛевое) И Не ЗначениеЗаполнено(ЗначениеПравое) Тогда
			ИначеЕсли ЗначениеЛевое <> ЗначениеПравое Тогда
				ВызватьИсключение "Не удалось установить реквизит """+КЗ.Ключ+""" при иницилизации обработки выгрузки/загрузки данных.";
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ШинаИнфо(Шина) Экспорт
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Шины.Ссылка КАК Ссылка,
	|	Шины.ПометкаУдаления КАК ПометкаУдаления,
	|	Шины.Родитель КАК Родитель,
	|	Шины.ЭтоГруппа КАК ЭтоГруппа,
	|	Шины.Наименование КАК Наименование,
	|	Шины.Кластер КАК Кластер,
	|	Шины.ОбменНаправление КАК ОбменНаправление,
	|	Шины.Тема КАК Тема,
	|	Шины.Узел КАК Узел,
	|	Шины.КлючСердес КАК КлючСердес,
	|	Шины.ЗначениеСердес КАК ЗначениеСердес,
	|	Шины.ОбменДлительностьСеанса КАК ОбменДлительностьСеанса,
	|	Шины.ОбменКоличествоПотоков КАК ОбменКоличествоПотоков,
	|	Шины.ОбменПоРасписанию КАК ОбменПоРасписанию,
	|	Шины.ОбменРасписание КАК ОбменРасписание,
	|	Шины.ОбменРасписаниеРазброс КАК ОбменРасписаниеРазброс,
	|	Шины.Обработка КАК Обработка,
	|	Шины.КлиентТаймаут КАК КлиентТаймаут,
	|	Шины.ПриемПроцедура КАК ПриемПроцедура,
	|	Шины.ПриемВРеальномВремени КАК ПриемВРеальномВремени,
	|	Шины.ПриемТаймаутОжидания КАК ПриемТаймаутОжидания,
	|	ЕСТЬNULL(ЕСТЬNULL(Шины.ПользовательРеглЗадания, Шины.Родитель.ПользовательРеглЗадания), """") КАК ПользовательРеглЗадания
	|ИЗ
	|	Справочник.КафкаШины КАК Шины
	|ГДЕ
	|	Шины.Ссылка = &Ссылка");
	Запрос.УстановитьПараметр("Ссылка", Шина);
	РезультатЗапроса = Запрос.ВыполнитьПакет();
	
	Если РезультатЗапроса[0].Пустой() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Структура;
	
	Шапка = РезультатЗапроса[0].Выгрузить()[0];
	Для Каждого Колонка Из РезультатЗапроса[0].Колонки Цикл
		Результат.Вставить(Колонка.Имя, Шапка[Колонка.Имя]);
	КонецЦикла;
		
	Результат.ОбменРасписание = Результат.ОбменРасписание.Получить();
	
	Результат.Тема = Тема(Результат.Тема);
	
	Результат.Вставить("ТемаЭтоПрефикс", СтрЗаканчиваетсяНа(Результат.Тема, "*"));
	Если Результат.ТемаЭтоПрефикс Тогда
		Результат.Вставить("ТемаПрефикс", Лев(Результат.Тема, СтрДлина(Результат.Тема)-1));
	КонецЕсли;
	
	Возврат Новый ФиксированнаяСтруктура(Результат);
	
КонецФункции

Процедура ОбновитьРегламентныеЗадания(ШинаСсылка, Удалить=Неопределено) Экспорт
		
	ШинаИнфо = ШинаИнфо(ШинаСсылка);
			
	МассивЗаданийОтправка = Новый Массив;
	м = РегламентныеЗадания.ПолучитьРегламентныеЗадания(Новый Структура("Метаданные", Метаданные.РегламентныеЗадания.КафкаВыгрузка));
	Для Каждого Задание Из м Цикл
		Если Задание.Параметры=Неопределено Или Задание.Параметры.Количество()=0 Или ТипЗнч(Задание.Параметры[0])<>Тип("СправочникСсылка.КафкаШины") Или Не ЗначениеЗаполнено(Задание.Параметры[0]) Тогда
			УдалитьРегламентноеЗадание(Задание);
		ИначеЕсли Задание.Параметры[0] = ШинаСсылка Тогда
			МассивЗаданийОтправка.Добавить(Задание);
		КонецЕсли;
	КонецЦикла;
	
	МассивЗаданийПрием = Новый Массив;
	м = РегламентныеЗадания.ПолучитьРегламентныеЗадания(Новый Структура("Метаданные", Метаданные.РегламентныеЗадания.КафкаЗагрузка));
	Для Каждого Задание Из м Цикл
		Если Задание.Параметры=Неопределено Или Задание.Параметры.Количество()=0 Или ТипЗнч(Задание.Параметры[0])<>Тип("СправочникСсылка.КафкаШины") Или Не ЗначениеЗаполнено(Задание.Параметры[0]) Тогда
			УдалитьРегламентноеЗадание(Задание);
		ИначеЕсли Задание.Параметры[0] = ШинаСсылка Тогда
			МассивЗаданийПрием.Добавить(Задание);
		КонецЕсли;
	КонецЦикла;
	
	Если Удалить = Истина Или ШинаИнфо.ПометкаУдаления Тогда
		Для Каждого Задание Из МассивЗаданийОтправка Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		Для Каждого Задание Из МассивЗаданийПрием Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		Возврат;
	КонецЕсли;
		
	Если ШинаИнфо.ОбменНаправление = Перечисления.КафкаНаправленияОбмена.Выгрузка Тогда
		
		Для Каждого Задание Из МассивЗаданийПрием Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		
		Задание = Неопределено;
		
		Если МассивЗаданийОтправка.Количество() > 0 Тогда
			Задание = МассивЗаданийОтправка.Получить(0);
			МассивЗаданийОтправка.Удалить(0);
		КонецЕсли;
		
		Для Каждого Задание_ Из МассивЗаданийОтправка Цикл
			УдалитьРегламентноеЗадание(Задание_);
		КонецЦикла;
		
		ОбновитьРегламентноеЗадание(ШинаИнфо, Задание);
							
	ИначеЕсли ШинаИнфо.ОбменНаправление = Перечисления.КафкаНаправленияОбмена.Загрузка Тогда
		
		Для Каждого Задание Из МассивЗаданийОтправка Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		
		Задание = Неопределено;
		
		Если МассивЗаданийПрием.Количество() > 0 Тогда
			Задание = МассивЗаданийПрием.Получить(0);
			МассивЗаданийПрием.Удалить(0);
		КонецЕсли;
		
		Для Каждого Задание_ Из МассивЗаданийПрием Цикл
			УдалитьРегламентноеЗадание(Задание_);
		КонецЦикла;
		
		ОбновитьРегламентноеЗадание(ШинаИнфо, Задание);
											
	Иначе
		ВызватьИсключение "Неизвестное направление обмена шины: " + ШинаИнфо.ОбменНаправление;
	КонецЕсли;
	
КонецПроцедуры
Процедура ОбновитьРегламентноеЗадание(ШинаИнфо, Задание)
	
	Если ШинаИнфо.ОбменНаправление = Перечисления.КафкаНаправленияОбмена.Выгрузка Тогда
		ЗаданиеМетаданные = Метаданные.РегламентныеЗадания.КафкаВыгрузка;
	ИначеЕсли ШинаИнфо.ОбменНаправление = Перечисления.КафкаНаправленияОбмена.Загрузка Тогда
		ЗаданиеМетаданные = Метаданные.РегламентныеЗадания.КафкаЗагрузка;
	Иначе
		ВызватьИсключение "Неизвестное направление обмена шины: " + ШинаИнфо.ОбменНаправление;
	КонецЕсли;
	
	Если Задание = Неопределено Тогда
		Если ШинаИнфо.ПометкаУдаления Или Не ШинаИнфо.ОбменПоРасписанию Тогда
			Возврат;
		КонецЕсли;
		Задание = РегламентныеЗадания.СоздатьРегламентноеЗадание(ЗаданиеМетаданные);
	КонецЕсли;
	
	Расписание = Новый РасписаниеРегламентногоЗадания;
	ЗаполнитьЗначенияСвойств(Расписание, ШинаИнфо.ОбменРасписание);
	
	Если Расписание.ПериодПовтораВТечениеДня <> 0 И ШинаИнфо.ОбменРасписаниеРазброс <> 0 Тогда
		ГенераторСлучайныхЧисел = Новый ГенераторСлучайныхЧисел;
		Смещение = ГенераторСлучайныхЧисел.СлучайноеЧисло(0, ШинаИнфо.ОбменРасписаниеРазброс*2) - ШинаИнфо.ОбменРасписаниеРазброс;
		Расписание.ПериодПовтораВТечениеДня = Расписание.ПериодПовтораВТечениеДня + Смещение;
	КонецЕсли;
	
	Параметры = Новый Массив;
	Параметры.Добавить(ШинаИнфо.Ссылка);
	
	Задание.Параметры		= Параметры;
	Задание.Ключ			= ЗаданиеМетаданные.Ключ+"_"+ШинаИнфо.Ссылка.УникальныйИдентификатор();
	Задание.Наименование	= ЗаданиеМетаданные.Наименование+" ("+ШинаИнфо.Наименование+")";
	Задание.Расписание		= Расписание;
	Задание.Использование	= ШинаИнфо.ОбменПоРасписанию И Не ШинаИнфо.ПометкаУдаления;
	Задание.ИмяПользователя	= ШинаИнфо.ПользовательРеглЗадания;
	
	Задание.Записать();
	
	Если Не Задание.Использование Тогда
		ОтменитьФоновоеЗадание(Задание);
	КонецЕсли;
	
КонецПроцедуры
Процедура УдалитьРегламентноеЗадание(РегламентноеЗадание) Экспорт
	
	Если РегламентноеЗадание.Использование Тогда
		РегламентноеЗадание.Использование = Ложь;
		РегламентноеЗадание.Записать();
	КонецЕсли;
	
	ОтменитьФоновоеЗадание(РегламентноеЗадание);
	
	РегламентноеЗадание.Удалить();
		
КонецПроцедуры
Процедура ОтменитьФоновоеЗадание(РегламентноеЗадание)
	
	Отбор = Новый Структура;
	Отбор.Вставить("РегламентноеЗадание", РегламентноеЗадание);
	Отбор.Вставить("Состояние", СостояниеФоновогоЗадания.Активно);
	
	АктивныеФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(Отбор);
		
	Для Каждого ФоновоеЗадание Из АктивныеФоновыеЗадания Цикл
		ФоновоеЗадание.Отменить();
	КонецЦикла;
	
КонецПроцедуры

Функция Тема(ИсходнаяТема) Экспорт
		
	Если КафкаПовтИсп.ЭтоБэкап() Тогда
		Возврат "test-" + ИсходнаяТема;
	КонецЕсли;
	
	Возврат ИсходнаяТема;
	
КонецФункции

Функция ПолучитьЧитаемыеРазделы(Адаптер, Consumer, Тема)
	
	Partitions = Новый Массив;
	
	Если СтрЗаканчиваетсяНа(Тема, "*") Тогда
		
		topicInfos = Адаптер.ConsumerListTopics(Consumer, Тема);
		Если topicInfos = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ТемаПрефикс = Лев(Тема, СтрДлина(Тема)-1);
		
		Для Каждого КлючЗначение Из topicInfos Цикл
			Если СтрНачинаетсяС(КлючЗначение.Ключ, ТемаПрефикс) Тогда
				Для Каждого partitionInfo Из КлючЗначение.Значение Цикл
					Partitions.Добавить(Новый ФиксированнаяСтруктура("topic, partition", partitionInfo.topic, partitionInfo.partition));
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
				
	Иначе
		
		partitionInfos = Адаптер.ConsumerListPartitions(Consumer, Тема);
		Если partitionInfos = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Для Каждого partitionInfo Из partitionInfos Цикл
			Partitions.Добавить(Новый ФиксированнаяСтруктура("topic, partition", partitionInfo.topic, partitionInfo.partition));
		КонецЦикла;
				
	КонецЕсли;
	
	Возврат Partitions;
	
КонецФункции

Функция ПолучитьДеревоГраничныхСмещений(Адаптер, Consumer, Partitions)
	
	BeginningOffsets = Адаптер.ConsumerGetBeginningOffsets(Consumer, Partitions);
	
	Если BeginningOffsets = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	EndOffsets = Адаптер.ConsumerGetEndOffsets(Consumer, Partitions);
	
	Если EndOffsets = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СостоянияЧтения = Новый Соответствие;
	
	Для Каждого КлючЗначение Из BeginningOffsets Цикл
		
		СостоянияЧтенияТемы = СостоянияЧтения.Получить(КлючЗначение.Ключ);
		Если СостоянияЧтенияТемы = Неопределено Тогда
			СостоянияЧтенияТемы = Новый Соответствие;
			СостоянияЧтения.Вставить(КлючЗначение.Ключ, СостоянияЧтенияТемы);
		КонецЕсли;
		
		Для Каждого PartitionOffset Из КлючЗначение.Значение Цикл
			
			СостояниеЧтенияРаздела = СостоянияЧтенияТемы.Получить(PartitionOffset.partition);
			Если СостояниеЧтенияРаздела = Неопределено Тогда
				СостояниеЧтенияРаздела = Новый Структура;
				СостоянияЧтенияТемы.Вставить(PartitionOffset.partition, СостояниеЧтенияРаздела);
			КонецЕсли;
			
			СостояниеЧтенияРаздела.Вставить("НачальноеСмещение", PartitionOffset.offset);
			
		КонецЦикла;
		
	КонецЦикла;
	
	Для Каждого КлючЗначение Из EndOffsets Цикл
		
		СостоянияЧтенияТемы = СостоянияЧтения.Получить(КлючЗначение.Ключ);
		Если СостоянияЧтенияТемы = Неопределено Тогда
			СостоянияЧтенияТемы = Новый Соответствие;
			СостоянияЧтения.Вставить(КлючЗначение.Ключ, СостоянияЧтенияТемы);
		КонецЕсли;
		
		Для Каждого PartitionOffset Из КлючЗначение.Значение Цикл
			
			СостояниеЧтенияРаздела = СостоянияЧтенияТемы.Получить(PartitionOffset.partition);
			Если СостояниеЧтенияРаздела = Неопределено Тогда
				СостояниеЧтенияРаздела = Новый Структура;
				СостоянияЧтенияТемы.Вставить(PartitionOffset.partition, СостояниеЧтенияРаздела);
			КонецЕсли;
			
			СостояниеЧтенияРаздела.Вставить("КонечноеСмещение", PartitionOffset.offset);
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат СостоянияЧтения;
	
КонецФункции

Процедура ПолучитьСмещенияТемыВФоне(Кластер, Тема, АдресРезультата=Неопределено) Экспорт
	
	Адаптер = КафкаКлиентСервер.Адаптер(Кластер);
	
	Операция = "Получение смещений темы """+Тема+"""";
	Конфигурация = КонфигурацияПолучателя(Кластер);
	
	Результат = ПолучитьСмещенияТемы(Адаптер, Операция, Конфигурация, Тема);
	
	Если Результат <> Неопределено Тогда
		ОписаниеРезультата = Новый Структура;
		ОписаниеРезультата.Вставить("Успех", Истина);
		ОписаниеРезультата.Вставить("Результат", Результат);
	Иначе
		ОписаниеРезультата = Новый Структура;
		ОписаниеРезультата.Вставить("Успех", Ложь);
		ОписаниеРезультата.Вставить("ОписаниеОшибки", Строка(Адаптер.КодОтвета) + " " + Адаптер.ОписаниеОшибки);
	КонецЕсли;
	
	ПоместитьВоВременноеХранилище(ОписаниеРезультата, АдресРезультата);
	
КонецПроцедуры
Функция ПолучитьСмещенияТемы(Адаптер, Операция, Конфигурация, Тема)
		
	Consumer = Адаптер.ConsumerCreate(Операция, Конфигурация, 10000);
	Если Consumer = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		
		Partitions = ПолучитьЧитаемыеРазделы(Адаптер, Consumer, Тема);
		
		Результат = ПолучитьДеревоГраничныхСмещений(Адаптер, Consumer, Partitions);
		
		Адаптер.ConsumerRelease(Consumer);
	Исключение
		Адаптер.ConsumerRelease(Consumer);
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

Функция СтрокаСоединенияИБ() Экспорт
	
	Если КафкаПовтИсп.ЭтоФоновоеЗадание() Тогда
		Возврат СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	
	АдресРезультата = ПоместитьВоВременноеХранилище(Неопределено);
	
	Параметры = Новый Массив;
	Параметры.Добавить(АдресРезультата);
	
	Задание = ФоновыеЗадания.Выполнить(
			"КафкаСервер.ПолучитьСтрокуСоединенияИнформационнойБазыВФоне",
			Параметры,
			,
			"Кафка: Получение строки соединения информационной базы"
	);
	
	Пока Задание.Состояние = СостояниеФоновогоЗадания.Активно Цикл
		
		Задание = Задание.ОжидатьЗавершенияВыполнения(1);
		
	КонецЦикла;
	
	Если Задание.Состояние = СостояниеФоновогоЗадания.Завершено Тогда
		
		Результат = ПолучитьИзВременногоХранилища(АдресРезультата);
		
		УдалитьИзВременногоХранилища(АдресРезультата);	
		
	Иначе
		
		УдалитьИзВременногоХранилища(АдресРезультата);	
		
		Если Задание.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда
			
			ОписаниеОшибки = ?(Задание.ИнформацияОбОшибке = Неопределено,
					"Фоновое задание завершилось с неизвестнос ошибкой.",
			        ПодробноеПредставлениеОшибки(Задание.ИнформацияОбОшибке)
			);
			
		ИначеЕсли Задание.Состояние = СостояниеФоновогоЗадания.Отменено Тогда
			
			ОписаниеОшибки = "Фоновое задание было отменено.";
			
		ИначеЕсли Задание.Состояние <> СостояниеФоновогоЗадания.Завершено Тогда
			
			ОписаниеОшибки = "Неожиданное состояние фонового задания: "+Задание.Состояние+".";
			
		КонецЕсли;
		
		ВызватьИсключение ОписаниеОшибки;
		
	КонецЕсли;
		
	Возврат Результат;
	
КонецФункции

Процедура ПолучитьСтрокуСоединенияИнформационнойБазыВФоне(АдресРезультата) Экспорт
	
	Результат = СтрокаСоединенияИнформационнойБазы();
	
	ПоместитьВоВременноеХранилище(Результат, АдресРезультата);
	
КонецПроцедуры

Функция ЭтоФоновоеЗадание() Экспорт
	
	ТекущийСеансИБ = ПолучитьТекущийСеансИнформационнойБазы();
	ТекущееФЗ = ТекущийСеансИБ.ПолучитьФоновоеЗадание();
	
	Возврат (ТекущееФЗ <> Неопределено);
	
КонецФункции

#КонецОбласти
