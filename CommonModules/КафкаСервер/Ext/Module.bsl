#Область Выгрузка

Процедура ВыгрузитьРегламент(Шина) Экспорт
	
	Если КафкаПовтИсп.ЭтоБэкап() И Не КафкаПереопределяемый.РазрешенОбменБэкапов() Тогда
		ТекстСообщения = "Обмен бэкапов запрещен. Выгрузка не будет запущена.";
		КафкаКлиентСервер.СообщитьПользователю(ТекстСообщения);
		ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+Шина.Наименование, УровеньЖурналаРегистрации.Предупреждение, , , ТекстСообщения);
		Возврат;
	КонецЕсли;
		
	Выгрузить(Шина);
	
КонецПроцедуры

Процедура Выгрузить(Шина) Экспорт
	
	Если Не ЗначениеЗаполнено(Шина) Тогда
		ВызватьИсключение "Не заполнена шина. Выгрузка невозможна.";
	КонецЕсли;
	
	ШинаИнфо = ШинаИнфо(Шина);
		
	Если Не ЗначениеЗаполнено(ШинаИнфо.Узел) Тогда
		ВызватьИсключение "Не заполнен узел шины. Выгрузка невозможна.";
	КонецЕсли;
					
	Изменения = ПолучитьИзменения(ШинаИнфо.Узел, ШинаИнфо.ОтправкаБлокироватьТаблицуРегистрации);
	Если Изменения.Количество() = 0 Тогда
		Возврат; // нечего выгружать
	КонецЕсли;
	
	Обработка = КафкаПереопределяемый.ПолучитьОбработку(ШинаИнфо);
	
	// Установим реквизиты обработки.
	ПотенциальныеРеквизитыОбработки = Новый Структура;
	ПотенциальныеРеквизитыОбработки.Вставить("Узел", ШинаИнфо.Узел);
	ПотенциальныеРеквизитыОбработки.Вставить("Шина", ШинаИнфо.Ссылка);
	УстановитьРеквизитыОбработки(Обработка, ПотенциальныеРеквизитыОбработки);
	
	Заголовки = Новый Структура;
	
	// Проверка разрешений на выгрузку для текущего узла.
	Если Не Обработка.ПередВыгрузкойУзла(Заголовки) Тогда
		Возврат;
	КонецЕсли;
	
	// Инициализируем API Кафки.
	Кафка = API(ШинаИнфо.Кластер);
	
	// Создадим экземпляр отправителя внутри прокси.
	ProducerConfig = Справочники.КафкаШиныОбмена.КафкаКонфигурация(ШинаИнфо.Ссылка);
	Producer = Кафка.ProducerCreate(ШинаИнфо.Наименование, ProducerConfig, ШинаИнфо.КлиентТаймаут);
	Если Producer = Неопределено Тогда
		ВызватьИсключение Кафка.ОписаниеОшибки;
	КонецЕсли;
	
	// Конструкция, гарантирующая удаление экземпляра отправителя независимо от того, чем завершится отправка.
	Попытка
		
		ВыгружаемыеТаблицы = Обработка.ВыгружаемыеТаблицы();
		
		Параллелизм = ИнициализироватьПараллелизм(ШинаИнфо.ОтправкаПараллелизм);
		ПредПорядок = Неопределено;
		//ПредПакетныйРежим = Неопределено;
		
		Для Каждого ВыгружаемаяТаблица Из ВыгружаемыеТаблицы Цикл
					
			РезультатЗапросаИзменения = Изменения.Получить(ВыгружаемаяТаблица.ПолноеИмя);
			Если РезультатЗапросаИзменения = Неопределено Тогда
				Продолжить; // нечего выгружать по текущей таблице
			КонецЕсли;
			
			// Перед началом выгрузки данных нового порядка дожидаемся завершения выгрузки данных старого порядка.
			Если ПредПорядок <> ВыгружаемаяТаблица.Порядок Тогда
				ДождатьсяЗавершенияВсехПотоков(Параллелизм);
			КонецЕсли;
			
			ПредПорядок = ВыгружаемаяТаблица.Порядок;
			//ПредПакетныйРежим = ВыгружаемаяТаблица.ПакетныйРежим;
						
			ВыгрузитьТаблицу(ШинаИнфо, Обработка, Producer, ВыгружаемаяТаблица, РезультатЗапросаИзменения, Заголовки, Параллелизм);
					
		КонецЦикла;
			
		ДождатьсяЗавершенияВсехПотоков(Параллелизм);
		
		Кафка.ProducerRelease(Producer.Id, Producer.Token);
		
	Исключение
		
		Кафка.ProducerRelease(Producer.Id, Producer.Token);
		
		ВызватьИсключение;
		
	КонецПопытки;
		
	Обработка.ПослеВыгрузкиУзла();
	
КонецПроцедуры

Функция ПолучитьИзменения(Узел, Блокировать=Ложь)
		
	МассивТекстЗапроса = Новый Массив;
	МассивИменаТаблиц  = Новый Массив;
	
	СоставТаблиц = Узел.Метаданные().Состав;
	
	Если Блокировать Тогда
		Блокировка = Новый БлокировкаДанных;
	КонецЕсли;
	
	Для Каждого ЭлементСостава Из СоставТаблиц Цикл
		ТаблицаИнфо = КафкаПовтИсп.ОписаниеТаблицы(ЭлементСостава.Метаданные.ПолноеИмя());
		
		Если ТаблицаИнфо.ЭтоКонстанта Тогда
			МассивТекстЗапроса.Добавить(
			"ВЫБРАТЬ
			|	ИСТИНА
			|ИЗ
			|	" + ТаблицаИнфо.ПолноеИмя + ".Изменения
			|ГДЕ
			|	Узел = &Узел"); 
		ИначеЕсли ТаблицаИнфо.ЭтоСсылочныйОбъект Тогда
			МассивТекстЗапроса.Добавить(
			"ВЫБРАТЬ
			|	Изменения.Ссылка,
			|	ВЫБОР
			|		КОГДА ОсновнаяТаблица.Ссылка ЕСТЬ NULL 
			|			ТОГДА ИСТИНА
			|		ИНАЧЕ ЛОЖЬ
			|	КОНЕЦ КАК ЭтоУдаление
			|ИЗ
			|	" + ТаблицаИнфо.ПолноеИмя + ".Изменения КАК Изменения
			|		ЛЕВОЕ СОЕДИНЕНИЕ " + ТаблицаИнфо.ПолноеИмя + " КАК ОсновнаяТаблица
			|		ПО Изменения.Ссылка = ОсновнаяТаблица.Ссылка
			|ГДЕ
			|	Изменения.Узел = &Узел"); 
		Иначе
			СтрокаИзмерения = ?(ТаблицаИнфо.КлючевыеПоля.Количество()=0, "ИСТИНА", СтрСоединить(ТаблицаИнфо.КлючевыеПоля, ","));
			МассивТекстЗапроса.Добавить(
			"ВЫБРАТЬ
			|	" + СтрокаИзмерения + "
			|ИЗ
			|	" + ТаблицаИнфо.ПолноеИмя + ".Изменения
			|ГДЕ
			|	Узел = &Узел");
		КонецЕсли;
		
		МассивИменаТаблиц.Добавить(ТаблицаИнфо.ПолноеИмя);
		
		Если Блокировать Тогда
			ЭлементБлокировки = Блокировка.Добавить(ТаблицаИнфо.ПолноеИмя+?(ТаблицаИнфо.ЭтоПодчиненныйРегистр Или ТаблицаИнфо.ЭтоПоследовательность, ".НаборЗаписей", ""));
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		КонецЕсли;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = СтрСоединить(МассивТекстЗапроса, Символы.ПС+";"+Символы.ПС);
	Запрос.УстановитьПараметр("Узел", Узел);
	
	Если Блокировать Тогда
		
		КоличествоПопыток = 10;
		Пока Истина Цикл
			КоличествоПопыток = КоличествоПопыток - 1;
			
			НачатьТранзакцию();
			
			Попытка
				
				Блокировка.Заблокировать();
				
				МассивРезультаты = Запрос.ВыполнитьПакет();
				
				ЗафиксироватьТранзакцию();
				
				Прервать;
			Исключение
				ИнформацияОбОшибке = ИнформацияОбОшибке();
							
				ОтменитьТранзакцию();
				
				Если КоличествоПопыток > 0 Тогда
					ОписаниеОшибки = КафкаКлиентСервер.КорневаяИнформацияОбОшибке(ИнформацияОбОшибке).Описание;
					ОписаниеОшибкиНРег = НРег(ОписаниеОшибки);
					Если Найти(ОписаниеОшибкиНРег, "блокиров")>0 Или Найти(ОписаниеОшибкиНРег, "lock")>0 Тогда
						Продолжить;
					КонецЕсли;
				КонецЕсли;
					
				ВызватьИсключение;
			КонецПопытки
		КонецЦикла;
		
	Иначе
		
		МассивРезультаты = Запрос.ВыполнитьПакет();
		
	КонецЕсли;
		
	Результат = Новый Соответствие;
	Для индекс = 0 По МассивИменаТаблиц.ВГраница() Цикл
		РезультатЗапроса = МассивРезультаты[индекс];
		Если Не РезультатЗапроса.Пустой() Тогда
			Результат.Вставить(МассивИменаТаблиц[индекс], РезультатЗапроса);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура ВыгрузитьТаблицу(ШинаИнфо, Обработка, Producer, Таблица, РезультатЗапросаИзменения, ОбщиеЗаголовки, Параллелизм)
	
	Если ЗначениеЗаполнено(Таблица.РазмерПакета) Тогда
		РазмерПакета = Таблица.РазмерПакета;
	Иначе
		РазмерПакета = 250;
	КонецЕсли;
	
	// Скопируем общие заголовки.
	Заголовки = Новый Структура;
	Для Каждого КЗ Из ОбщиеЗаголовки Цикл
		Заголовки.Вставить(КЗ.Ключ, КЗ.Значение);
	КонецЦикла;
	
	ТаблицаИнфо = КафкаПовтИсп.ОписаниеТаблицы(Таблица.ПолноеИмя);
	
	Если Не Обработка.ПередВыгрузкойТаблицы(ТаблицаИнфо, Заголовки) Тогда
		Возврат;
	КонецЕсли;
								
	ИзмененияВыборка = РезультатЗапросаИзменения.Выбрать();
	
	ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
			УровеньЖурналаРегистрации.Примечание, ШинаИнфо.Узел.Метаданные(), ШинаИнфо.Узел,
			"Начата асинхронная отправка "+ИзмененияВыборка.Количество()+" объектов таблицы '"+Таблица+"'.");
			
	ТекущийПакет = Неопределено;
						
	// Обходим все измененные/удаленные объекты.
	Пока ИзмененияВыборка.Следующий() Цикл
		
		Если ТекущийПакет = Неопределено Тогда
			
			Данные = Новый ТаблицаЗначений;
			Для Каждого Колонка Из РезультатЗапросаИзменения.Колонки Цикл
				Данные.Колонки.Добавить(Колонка.Имя);
			КонецЦикла;
			
			ТекущийПакет = Новый Структура("ТаблицаИнфо, Заголовки, Данные, Размер", ТаблицаИнфо, Заголовки, Данные, 0);
						
		КонецЕсли;					
				
		ЗаполнитьЗначенияСвойств(ТекущийПакет.Данные.Добавить(), ИзмененияВыборка);
		ТекущийПакет.Размер = ТекущийПакет.Размер + 1;
		
		Если ТекущийПакет.Размер >= Таблица.РазмерПакета Тогда
			ВыгрузитьПакет(ШинаИнфо, Обработка, Producer, Параллелизм, ТекущийПакет, Таблица.ПакетныйРежим);
			ТекущийПакет = Неопределено;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ТекущийПакет <> Неопределено Тогда
		ВыгрузитьПакет(ШинаИнфо, Обработка, Producer, Параллелизм, ТекущийПакет, Таблица.ПакетныйРежим);
		ТекущийПакет = Неопределено;
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
			УровеньЖурналаРегистрации.Примечание, ШинаИнфо.Узел.Метаданные(), ШинаИнфо.Узел,
			"Завершена асинхронная отправка "+ИзмененияВыборка.Количество()+" объектов таблицы '"+Таблица+"'.");
	
КонецПроцедуры

Процедура ВыгрузитьПакет(ШинаИнфо, Обработка, Producer, Параллелизм, Пакет, Группировать)
	
	ДождатьсяОсвобожденияПулаПотоков(Параллелизм);	
		
	Если Параллелизм.МаксСтепень < 2 Тогда
		// Выгрузим пакет в этом же сеансе.
		
		ВыгрузитьПакетЭтотСеанс(ШинаИнфо, Обработка, Producer.Id, Producer.Token, Пакет, Группировать);
		
    Иначе
		// Выгрузим пакет в отдельном фоновом сеансе.
		
		Параллелизм.ПотокиСчетчик = Параллелизм.ПотокиСчетчик + 1;
		
		ПараметрыФЗ = Новый Массив;
		ПараметрыФЗ.Добавить(ШинаИнфо);
		ПараметрыФЗ.Добавить(Producer.Id);
		ПараметрыФЗ.Добавить(Producer.Token);
		ПараметрыФЗ.Добавить(Пакет);
		ПараметрыФЗ.Добавить(Группировать);
		
		ФЗ = ФоновыеЗадания.Выполнить("КафкаСервер.ВыгрузитьПакетОтдельныйСеанс", ПараметрыФЗ, ,
				"Поток выгрузки данных в шину '"+ШинаИнфо.Наименование+"' № "+Параллелизм.ПотокиСчетчик);
				
		Параллелизм.Потоки.Добавить(ФЗ);
		
	КонецЕсли;
		
КонецПроцедуры

Процедура ВыгрузитьПакетОтдельныйСеанс(ШинаИнфо, ProducerId, ProducerToken, Пакет, Группировать) Экспорт
	
	Обработка = КафкаПереопределяемый.ПолучитьОбработку(ШинаИнфо);
	
	// Установим реквизиты обработки.
	ПотенциальныеРеквизитыОбработки = Новый Структура;
	ПотенциальныеРеквизитыОбработки.Вставить("Узел", ШинаИнфо.Узел);
	ПотенциальныеРеквизитыОбработки.Вставить("Шина", ШинаИнфо.Ссылка);
	УстановитьРеквизитыОбработки(Обработка, ПотенциальныеРеквизитыОбработки);
	
	ВыгрузитьПакетЭтотСеанс(ШинаИнфо, Обработка, ProducerId, ProducerToken, Пакет, Группировать);
	
КонецПроцедуры

Процедура ВыгрузитьПакетЭтотСеанс(ШинаИнфо, Обработка, ProducerId, ProducerToken, Пакет, Группировать)
	
	Если Группировать Тогда
		
		ВыгрузитьПакетПакетно(ШинаИнфо, Обработка, ProducerId, ProducerToken, Пакет);
		
	Иначе
		
		ВыгрузитьПакетПообъектно(ШинаИнфо, Обработка, ProducerId, ProducerToken, Пакет);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ВыгрузитьПакетПообъектно(ШинаИнфо, Обработка, ProducerId, ProducerToken, Пакет)
	
	// Инициализируем соединение с Кафкой.
	Кафка = API(ШинаИнфо.Кластер);
	
	Обработка.ПередВыгрузкойПакета(Кафка);
			
	ТаблицаИнфо = Пакет.ТаблицаИнфо;
	ОбщиеЗаголовки = Пакет.Заголовки;
	
	Для Каждого СтрокаПакета Из Пакет.Данные Цикл
		
		// Скопируем общие заголовки.
		Заголовки = Новый Структура;
		Для Каждого КЗ Из ОбщиеЗаголовки Цикл
			Заголовки.Вставить(КЗ.Ключ, КЗ.Значение);
		КонецЦикла;
		
		// Итерацию выгрузки каждого объекта выполняем в отдельной транзакции.
		// Внутри транзакции только необходимый минимум действий.
		НачатьТранзакцию();
		
		// Устанавливаем разделяемую блокировку 
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить(ТаблицаИнфо.ПолноеИмя+?(ТаблицаИнфо.ЭтоПодчиненныйРегистр Или ТаблицаИнфо.ЭтоПоследовательность, ".НаборЗаписей", ""));
		Для Каждого Поле Из ТаблицаИнфо.КлючевыеПоля Цикл
			ЭлементБлокировки.УстановитьЗначение(Поле, СтрокаПакета[Поле]);
		КонецЦикла;
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		Блокировка.Заблокировать();
		
		// Читаем объект.
		Если ТаблицаИнфо.ЭтоКонстанта Тогда
			
			Объект = Константы[ТаблицаИнфо.Имя].СоздатьМенеджерЗначения();
			Объект.Прочитать();
		
		ИначеЕсли ТаблицаИнфо.ЭтоСсылочныйОбъект Тогда
			
			Если СтрокаПакета.ЭтоУдаление Тогда
				Объект = Новый УдалениеОбъекта(СтрокаПакета.Ссылка);
			Иначе // Это обычное изменение
				Объект = СтрокаПакета.Ссылка.ПолучитьОбъект();
			КонецЕсли;
				
		Иначе // Это регистр или последовательность
		
			РегистрМенеджер = КафкаПовтИсп.МенеджерТаблицы(ТаблицаИнфо.ПолноеИмя);
			
			Объект = РегистрМенеджер.СоздатьНаборЗаписей();
			Для Каждого Поле Из ТаблицаИнфо.КлючевыеПоля Цикл
				Объект.Отбор[Поле].Установить(СтрокаПакета[Поле]);
			КонецЦикла;
			Объект.Прочитать();
			
		КонецЕсли;
					
		// Разрегистрируем объект.
		ПланыОбмена.УдалитьРегистрациюИзменений(ШинаИнфо.Узел, Объект);
		
		ВыгружатьОбъект = Обработка.ПередВыгрузкойОбъекта(Объект, ТаблицаИнфо, Заголовки);
		Если ВыгружатьОбъект Тогда
		
			// Сериализуем объект
			СхемаЗначения = Неопределено; // Для бинарной сериализации.
			Значение = Обработка.СериализоватьОбъект(Объект, ТаблицаИнфо, Заголовки, СхемаЗначения);
			
			// Ключ сообщения нужен для правильного распределения объектов по разделам (партициям).
			// По умолчанию этот ключ одинаков для ссылочных объектов и зависимых наборов записей.
			// Таким образом регистраторы и их наборы записей попадут в один раздел и будут прочитаны в правильном порядке.
			СхемаКлюча = Неопределено; // Для бинарной сериализации.
			Ключ = Обработка.КлючОбъекта(Объект, ТаблицаИнфо, СхемаКлюча);
							
			// Отправляем данные. Это должно быть самое последнее действие в транзакции.
			DeliveryResult = Кафка.ProducerProduce(
					ProducerId, ProducerToken, ШинаИнфо.Тема, , Значение, Ключ, Заголовки, СхемаЗначения, СхемаКлюча);
			Если DeliveryResult = Неопределено Тогда
				ОтменитьТранзакцию();
				ВызватьИсключение Кафка.ОписаниеОшибки;
			ИначеЕсли DeliveryResult.Status <> "Persisted" Тогда
				ОтменитьТранзакцию();
				ВызватьИсключение "Не удалось отправить сообщение. Статус доставки: '"+DeliveryResult.Status+"'."; // TODO: Более подробная причина.
			КонецЕсли;
								
		КонецЕсли;
					
		ЗафиксироватьТранзакцию();
		
		Если ВыгружатьОбъект Тогда
			Обработка.ПослеВыгрузкиОбъекта(Объект, ТаблицаИнфо, DeliveryResult);
		КонецЕсли;
		
	КонецЦикла;
		
КонецПроцедуры

Процедура ВыгрузитьПакетПакетно(ШинаИнфо, Обработка, ProducerId, ProducerToken, Пакет)
	
	// Инициализируем соединение с Кафкой.
	Кафка = API(ШинаИнфо.Кластер);
	
	Обработка.ПередВыгрузкойПакета(Кафка);
				
	ТаблицаИнфо = Пакет.ТаблицаИнфо;
	ОбщиеЗаголовки = Пакет.Заголовки;
	
	// Скопируем общие заголовки.
	Заголовки = Новый Структура;
	Для Каждого КЗ Из Пакет.Заголовки Цикл
		Заголовки.Вставить(КЗ.Ключ, КЗ.Значение);
	КонецЦикла;
	
	НачатьТранзакцию();
	
	// Устанавливаем разделяемую блокировку 
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить(ТаблицаИнфо.ПолноеИмя+?(ТаблицаИнфо.ЭтоПодчиненныйРегистр Или ТаблицаИнфо.ЭтоПоследовательность, ".НаборЗаписей", ""));
	ЭлементБлокировки.ИсточникДанных = Пакет.Данные;
	Для Каждого Поле Из ТаблицаИнфо.КлючевыеПоля Цикл
		ЭлементБлокировки.ИспользоватьИзИсточникаДанных(Поле, Поле);
	КонецЦикла;
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
	Блокировка.Заблокировать();
	
	МассивОбъектов = Новый Массив;
	
	Для Каждого СтрокаПакета Из Пакет.Данные Цикл
								
		// Читаем объект.
		Если ТаблицаИнфо.ЭтоКонстанта Тогда
			
			Объект = Константы[ТаблицаИнфо.Имя].СоздатьМенеджерЗначения();
			Объект.Прочитать();
		
		ИначеЕсли ТаблицаИнфо.ЭтоСсылочныйОбъект Тогда
			
			Если СтрокаПакета.ЭтоУдаление Тогда
				Объект = Новый УдалениеОбъекта(СтрокаПакета.Ссылка);
			Иначе // Это обычное изменение
				Объект = СтрокаПакета.Ссылка.ПолучитьОбъект();
			КонецЕсли;
				
		Иначе // Это регистр или последовательность
		
			РегистрМенеджер = КафкаПовтИсп.МенеджерТаблицы(ТаблицаИнфо.ПолноеИмя);
			
			Объект = РегистрМенеджер.СоздатьНаборЗаписей();
			Для Каждого Поле Из ТаблицаИнфо.КлючевыеПоля Цикл
				Объект.Отбор[Поле].Установить(СтрокаПакета[Поле]);
			КонецЦикла;
			Объект.Прочитать();
			
		КонецЕсли;
					
		// Разрегистрируем объект.
		ПланыОбмена.УдалитьРегистрациюИзменений(ШинаИнфо.Узел, Объект);
		
		ВыгружатьОбъект = Обработка.ПередВыгрузкойОбъекта(Объект, ТаблицаИнфо, Заголовки);
		
		Если ВыгружатьОбъект Тогда
			МассивОбъектов.Добавить(Объект);
		КонецЕсли;
			
	КонецЦикла;
	
	Если МассивОбъектов.Количество() > 0 Тогда
	
		// Сериализуем объект
		СхемаЗначения = Неопределено; // Для бинарной сериализации.
		Значение = Обработка.СериализоватьПакет(МассивОбъектов, ТаблицаИнфо, Заголовки, СхемаЗначения);
		
		СхемаКлюча = Неопределено; // Для бинарной сериализации.
		Ключ = Обработка.КлючПакета(МассивОбъектов, ТаблицаИнфо, СхемаКлюча);
						
		// Отправляем данные. Это должно быть самое последнее действие в транзакции.
		DeliveryResult = Кафка.ProducerProduce(ProducerId, ProducerToken, ШинаИнфо.Тема, , Значение, Ключ, Заголовки, СхемаЗначения, СхемаКлюча);
		Если DeliveryResult = Неопределено Тогда
			ОтменитьТранзакцию();
			ВызватьИсключение Кафка.ОписаниеОшибки;
		ИначеЕсли DeliveryResult.Status <> "Persisted" Тогда
			ОтменитьТранзакцию();
			ВызватьИсключение "Не удалось отправить сообщение. Статус доставки: '"+DeliveryResult.Status+"'."; // TODO: Более подробная причина.
		КонецЕсли;
		
	КонецЕсли;
		
	ЗафиксироватьТранзакцию();
		
	Если МассивОбъектов.Количество() > 0 Тогда
		Обработка.ПослеВыгрузкиПакета(МассивОбъектов, ТаблицаИнфо, DeliveryResult);
	КонецЕсли;
	
КонецПроцедуры

#Область ВыгрузкаВспомогательныеФункции

Функция ИнициализироватьПараллелизм(МаксСтепень)
		
	Результат = Новый Структура;
	
	Результат.Вставить("МаксСтепень", МаксСтепень);
	Результат.Вставить("Потоки", Новый Массив);
	Результат.Вставить("ПотокиСчетчик", 0);
	//Результат.Вставить("РазмерПакета");
	//Результат.Вставить("ТекущийПакет");
	
	Возврат Результат;
	
КонецФункции

Процедура ДождатьсяОсвобожденияПулаПотоков(Параллелизм, УчитыватьСтепеньПараллелизма=Истина)
	
	Если УчитыватьСтепеньПараллелизма И Параллелизм.Потоки.Количество()<Параллелизм.МаксСтепень Тогда
		Возврат;
	КонецЕсли;
	
	Параллелизм.Потоки = ФоновыеЗадания.ОжидатьЗавершенияВыполнения(Параллелизм.Потоки);
		
	Колво = Параллелизм.Потоки.Количество();
	Индекс = Колво;
	Пока Индекс > 0 Цикл
		Индекс = Индекс - 1;
		ФЗ = Параллелизм.Потоки[Индекс];
		Если ФЗ.Состояние = СостояниеФоновогоЗадания.Активно Тогда
		ИначеЕсли ФЗ.Состояние = СостояниеФоновогоЗадания.Завершено Тогда
			Параллелизм.Потоки.Удалить(Индекс);
		ИначеЕсли ФЗ.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда
			ОписаниеОшибки = "Один из потоков завершился ошибкой.";
			Если ФЗ.ИнформацияОбОшибке <> Неопределено Тогда
				ОписаниеОшибки = ОписаниеОшибки + Символы.ПС + ПодробноеПредставлениеОшибки(ФЗ.ИнформацияОбОшибке);
			КонецЕсли;
			ВызватьИсключение ОписаниеОшибки;
		ИначеЕсли ФЗ.Состояние = СостояниеФоновогоЗадания.Отменено Тогда
			ВызватьИсключение "Один из потоков был вручную отменен.";
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ДождатьсяЗавершенияВсехПотоков(Параллелизм)
	
	Пока Параллелизм.Потоки.Количество() > 0 Цикл
		ДождатьсяОсвобожденияПулаПотоков(Параллелизм, Ложь)
	КонецЦикла;
		
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область Загрузка

Процедура ЗагрузитьРегламент(Шина, Раздел=Неопределено) Экспорт
	
	Если КафкаПовтИсп.ЭтоБэкап() И Не КафкаПереопределяемый.РазрешенОбменБэкапов() Тогда
		ТекстСообщения = "Обмен бэкапов запрещен. Загрузка не будет запущена.";
		КафкаКлиентСервер.СообщитьПользователю(ТекстСообщения);
		ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+Шина.Наименование, УровеньЖурналаРегистрации.Предупреждение, , , ТекстСообщения);
		Возврат;
	КонецЕсли;
	
	Загрузить(Шина, Раздел);
	
КонецПроцедуры

Процедура Загрузить(Шина, Раздел=Неопределено) Экспорт
	
	МоментСтарта = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	ШинаИнфо = ШинаИнфо(Шина);
	Если ШинаИнфо = Неопределено Тогда
		ВызватьИсключение "Некорректная шина.";
	КонецЕсли;
	
	// Инициализируем обработку загрузки данных.
	Обработка = КафкаПереопределяемый.ПолучитьОбработку(ШинаИнфо);
	Если Обработка = Неопределено Тогда
		ВызватьИсключение "Не удалось инициализировать обработку обмена для шины """+Шина+""".";
	КонецЕсли;
	
	// Установим реквизиты обработки.
	ПотенциальныеРеквизитыОбработки = Новый Структура;
	ПотенциальныеРеквизитыОбработки.Вставить("Узел", ШинаИнфо.Узел);
	ПотенциальныеРеквизитыОбработки.Вставить("Шина", ШинаИнфо.Ссылка);
	УстановитьРеквизитыОбработки(Обработка, ПотенциальныеРеквизитыОбработки);
	
	// Инициализируем API Кафки.
	Кафка = API(ШинаИнфо.Кластер);
	
	// Инициализируем параметры получателя.
	ConsumerConfig = Справочники.КафкаШиныОбмена.КафкаКонфигурация(ШинаИнфо.Ссылка);
	Если ConsumerConfig.Получить("group.id") = Неопределено Тогда 
		ConsumerConfig.Вставить("group.id", КафкаПовтИсп.ГруппаПолучателей());
	КонецЕсли;
	ConsumerConfig.Вставить("enable.partition.eof", XMLСтрока(Не ШинаИнфо.ПриемВРеальномВремени));
		
	// Создаем экземпляр получателя внутри прокси, который будет читать сообщения для нас.
	Consumer = Кафка.ConsumerCreate(ШинаИнфо.Наименование, ConsumerConfig, ШинаИнфо.КлиентТаймаут);
	Если Consumer = Неопределено Тогда
		ВызватьИсключение Кафка.ОписаниеОшибки;
	КонецЕсли;
	
	// Конструкция, гарантирующая удаление экземпляра получателя независимо от того, чем завершится чтение.
	Попытка

		// Формируем масив разделов, из которых будем читать сообщения.
		Partitions = Новый Массив;
		Если Раздел = Неопределено Тогда
			Md = Кафка.ConsumerGetMetadata(Consumer.Id, Consumer.Token, ШинаИнфо.Тема);
			Если Md = Неопределено Тогда
				ВызватьИсключение Кафка.ОписаниеОшибки;
			КонецЕсли;
			TopicMd = Md.Topics[0];
			Для Каждого PartitionMd Из TopicMd.Partitions Цикл
				Partitions.Добавить(Новый Структура("Topic, Partition", TopicMd.Topic, PartitionMd.Partition));
			КонецЦикла;
		Иначе
			Partitions.Добавить(Новый Структура("Topic, Partition", ШинаИнфо.Тема, Раздел));
		КонецЕсли;
		
		// Если по каким-то (или всем) разделам загрузка запрещена, удаляем разделы из массива.
		Индекс = Partitions.Количество();
		Пока Индекс > 0 Цикл
			Индекс = Индекс - 1;
			TopicPartition = Partitions[Индекс];
			Если Не Обработка.ПередЗагрузкойРаздела(TopicPartition.Topic, TopicPartition.Partition, Кафка) Тогда
				Partitions.Удалить(Индекс);
			КонецЕсли;
		КонецЦикла;
		Если Partitions.Количество() = 0 Тогда
			Возврат;
		КонецЕсли;
		
		Загрузить_(ШинаИнфо, Обработка, Кафка, Consumer, Partitions, МоментСтарта);
		
		Кафка.ConsumerRelease(Consumer.Id, Consumer.Token);
		
	Исключение
		
		Кафка.ConsumerRelease(Consumer.Id, Consumer.Token);
		
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры
Процедура Загрузить_(ШинаИнфо, Обработка, Кафка, Consumer, Assignment, МоментСтарта)
	
	ЕстьНовыеСообщения = Ложь;
	
	СостоянияЧтения = Новый Соответствие;
	
	Для Каждого TopicPartition Из Assignment Цикл
				
		// Получаем начальное и конечное смещения раздела.
		PartitionOffsets = Кафка.ConsumerQueryPartitionOffsets(Consumer.Id, Consumer.Token, TopicPartition.Topic, TopicPartition.Partition);
		Если PartitionOffsets = Неопределено Тогда
			ВызватьИсключение Кафка.ОписаниеОшибки;
		КонецЕсли;
		
		// Получаем последнюю зафиксированную позицию чтения.
		ТекущаяПозиция = РегистрыСведений.КафкаПозиции.ПолучитьПозицию(ШинаИнфо.Кластер, TopicPartition.Topic, TopicPartition.Partition);
		
		// Проверка корректности текущей позиции
		Если ТекущаяПозиция < PartitionOffsets.Low Тогда
			ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
					УровеньЖурналаРегистрации.Предупреждение, , TopicPartition.Topic+":"+Формат(TopicPartition.Partition, "ЧН=0; ЧГ=0"),
					"Начальная позиция раздела ("+Формат(PartitionOffsets.Low, "ЧН=0")+") больше текущей ("+Формат(ТекущаяПозиция, "ЧН=0")+"). Текущая позиция будет скорректирована.");
			ТекущаяПозиция = PartitionOffsets.Low;
		ИначеЕсли ТекущаяПозиция > PartitionOffsets.High Тогда
			ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
					УровеньЖурналаРегистрации.Предупреждение, , TopicPartition.Topic+":"+Формат(TopicPartition.Partition, "ЧН=0; ЧГ=0"),
					"Конечная позиция раздела ("+Формат(PartitionOffsets.High, "ЧН=0")+") меньше текущей ("+Формат(ТекущаяПозиция, "ЧН=0")+"). Текущая позиция будет скорректирована.");
			ТекущаяПозиция = PartitionOffsets.High;
		КонецЕсли;
		
		// Установим начальную позицию, с которой будут прочитаны сообщения раздела.
		TopicPartition.Вставить("Offset", ТекущаяПозиция);
		
		СостоянияЧтенияТопика = СостоянияЧтения.Получить(TopicPartition.Topic);
		Если СостоянияЧтенияТопика = Неопределено Тогда
			СостоянияЧтенияТопика = Новый Соответствие;
			СостоянияЧтения.Вставить(TopicPartition.Topic, СостоянияЧтенияТопика);
		КонецЕсли;
		
		СостояниеЧтенияРаздела = Новый Структура("НачальноеСмещение, КонечноеСмещение, ТекущаяПозиция", PartitionOffsets.Low, PartitionOffsets.High, ТекущаяПозиция);
		СостояниеЧтенияРаздела.Вставить("НачальноеСмещение"	, PartitionOffsets.Low);
		СостояниеЧтенияРаздела.Вставить("КонечноеСмещение"	, PartitionOffsets.High);
		СостояниеЧтенияРаздела.Вставить("ТекущаяПозиция"	, ТекущаяПозиция);
		
		СостоянияЧтенияТопика.Вставить(TopicPartition.Partition, СостояниеЧтенияРаздела);
		
		ЕстьНовыеСообщения = ЕстьНовыеСообщения Или (ТекущаяПозиция<PartitionOffsets.High);
		
	КонецЦикла;
	
	// Если длительность приема равна нулю и нет новых сообщений,
	// нет смысла инициировать получение сообщений.
	Если ЕстьНовыеСообщения Или ШинаИнфо.ПриемДлительность>0 Тогда
		
		ТекущаяУниверсальнаяДатаВМиллисекундах = ТекущаяУниверсальнаяДатаВМиллисекундах();
		Для Каждого TopicPartition Из Assignment Цикл
			
			СостояниеЧтенияРаздела = СостоянияЧтения[TopicPartition.Topic][TopicPartition.Partition];
			СостояниеЧтенияРаздела.Вставить("ПолученоСообщенийПослеПоследнейФиксации", 0);
			СостояниеЧтенияРаздела.Вставить("МоментПоследнейФиксации", ТекущаяУниверсальнаяДатаВМиллисекундах);
			
			ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
					УровеньЖурналаРегистрации.Информация, , TopicPartition.Topic+":"+Формат(TopicPartition.Partition, "ЧН=0; ЧГ=0"),
					"Начато чтение раздела. Начальная позиция: "+Формат(СостояниеЧтенияРаздела.ТекущаяПозиция, "ЧН=0")+".");
			
		КонецЦикла;
		
		// Назначим получателя читать сообщения из переданных топиков-разделов
		Assignment = Кафка.ConsumerAssign(Consumer.Id, Consumer.Token, Assignment);
		Если Assignment = Неопределено Тогда
			ВызватьИсключение Кафка.ОписаниеОшибки;
		КонецЕсли;
				
		ОсталосьРазделов = Assignment.Количество();
		
		Пока Истина Цикл
			
			// Получим новое сообщение
			Message = Кафка.ConsumerConsume(Consumer.Id, Consumer.Token, ШинаИнфо.ПриемТаймаутОжидания);
			
			Если Message = Неопределено Тогда
				ВызватьИсключение Кафка.ОписаниеОшибки;
			КонецЕсли;
			
			Если Message<>Null И Не Message.IsPartitionEOF Тогда

				СостояниеЧтенияРаздела = СостоянияЧтения[Message.Topic][Message.Partition];
				
				Если Message.Offset < СостояниеЧтенияРаздела.ТекущаяПозиция Тогда
					ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
							УровеньЖурналаРегистрации.Предупреждение, , Message.Topic+":"+Формат(Message.Partition, "ЧН=0; ЧГ=0"),
							"Позиция полученного сообщения ("+Формат(Message.Offset, "ЧН=0")+") меньше текущей ("+Формат(СостояниеЧтенияРаздела.ТекущаяПозиция, "ЧН=0")+"). Чтение не будет выполнено.");
					Прервать;
				ИначеЕсли Message.Offset > СостояниеЧтенияРаздела.ТекущаяПозиция Тогда
					ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
							УровеньЖурналаРегистрации.Предупреждение, , Message.Topic+":"+Формат(Message.Partition, "ЧН=0; ЧГ=0"),
							"Позиция полученного сообщения ("+Формат(Message.Offset, "ЧН=0")+") больше текущей ("+Формат(СостояниеЧтенияРаздела.ТекущаяПозиция, "ЧН=0")+").");
				КонецЕсли;
				
				// Обновление состояния чтения текущего раздела.
				СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации = СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации + 1;
				СостояниеЧтенияРаздела.ТекущаяПозиция = Message.Offset + 1;
				
				// Собственно, загрузка самого сообщения.
				Обработка.ЗагрузитьСообщение(Message);
				
			КонецЕсли;
			
			ТекущаяУниверсальнаяДатаВМиллисекундах = ТекущаяУниверсальнаяДатаВМиллисекундах();
			
			Если ШинаИнфо.ПриемДлительность<>0 И ТекущаяУниверсальнаяДатаВМиллисекундах-МоментСтарта>=ШинаИнфо.ПриемДлительность Тогда
				// Завершаем загрузку по истечению максимальной длительности.
				Прервать;
			КонецЕсли;
									
			Если ШинаИнфо.ПриемВРеальномВремени Тогда
				
				// Если долго не получаем новых сообщений, надо периодически проверять наличие незафиксированных позиций.
				Если Message = Null Тогда
					Для Каждого TopicPartition Из Assignment Цикл
						СостояниеЧтенияРаздела = СостоянияЧтения[TopicPartition.Topic][TopicPartition.Partition];
						ЗафиксироватьПозициюЧтения(ШинаИнфо.Кластер, TopicPartition.Topic, TopicPartition.Partition, СостояниеЧтенияРаздела, Обработка);
					КонецЦикла;
				КонецЕсли;
								
			Иначе
				
				Если Message = Null Тогда
					// Завершаем загрузку в случае отсутствия новых сообщений.
					Прервать;
				ИначеЕсли Message.IsPartitionEOF Тогда
					ОсталосьРазделов = ОсталосьРазделов - 1;
					Если ОсталосьРазделов = 0 Тогда
						// От всех разделов были получены маркеры отсутствия новых сообщений. Завершаем чтение.
						Прервать;
					КонецЕсли;
				КонецЕсли;
				
			КонецЕсли;
			
			Если Message<>Null И Не Message.IsPartitionEOF Тогда
				// Фиксируем текущую позицию чтения каждые 500 сообщений или каждые 20 секунд, смотря что наступит раньше.
				Если СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации >= 500
				Или ТекущаяУниверсальнаяДатаВМиллисекундах - СостояниеЧтенияРаздела.МоментПоследнейФиксации >= 20000 Тогда
					ЗафиксироватьПозициюЧтения(ШинаИнфо.Кластер, Message.Topic, Message.Partition, СостояниеЧтенияРаздела, Обработка)
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
		
		Для Каждого TopicPartition Из Assignment Цикл
			
			СостояниеЧтенияРаздела = СостоянияЧтения[TopicPartition.Topic][TopicPartition.Partition];
			
			// Финальная фиксация текущей позиции чтения.
			ЗафиксироватьПозициюЧтения(ШинаИнфо.Кластер, TopicPartition.Topic, TopicPartition.Partition, СостояниеЧтенияРаздела, Обработка);
			
			ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
			УровеньЖурналаРегистрации.Информация, , TopicPartition.Topic+":"+Формат(TopicPartition.Partition, "ЧН=0; ЧГ=0"),
			"Завершено чтение раздела. Конечная позиция: "+Формат(СостояниеЧтенияРаздела.ТекущаяПозиция, "ЧН=0")+".");
			
			РегистрыСведений.КафкаПозиции.УдалитьСтарые(ШинаИнфо.Кластер, TopicPartition.Topic, TopicPartition.Partition);
			
		КонецЦикла;

	КонецЕсли;
	
	Для Каждого TopicPartition Из Assignment Цикл
		СостояниеЧтенияРаздела = СостоянияЧтения[TopicPartition.Topic][TopicPartition.Partition];
		Обработка.ПослеЗагрузкиРаздела(СостояниеЧтенияРаздела.ТекущаяПозиция);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗафиксироватьПозициюЧтения(Кластер, Тема, Раздел, СостояниеЧтенияРаздела, Обработка)
	
	Если СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ТранзакцияАктивна() Тогда
		ВызватьИсключение "Во время фиксации позиции чтения транзакция не должна быть активна.";
	КонецЕсли;
	
	// В случае буферизации сообщений обработкой нужно синхронизировать сброс буфера и фиксацию позиции чтения.
	Обработка.СброситьБуферы();
	
	РегистрыСведений.КафкаПозиции.УстановитьПозицию(Кластер, Тема, Раздел, СостояниеЧтенияРаздела.ТекущаяПозиция);
	
	СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации = 0;
	СостояниеЧтенияРаздела.МоментПоследнейФиксации = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеФункции

Процедура УстановитьРеквизитыОбработки(Обработка, ПотенциальныеРеквизиты)
	
	ОбработкаМетаданные = Обработка.Метаданные();
	Для Каждого КЗ Из ПотенциальныеРеквизиты Цикл
		ОбработкаРеквизит = ОбработкаМетаданные.Реквизиты.Найти(КЗ.Ключ);
		Если ОбработкаРеквизит <> Неопределено Тогда
			Обработка[КЗ.Ключ] = КЗ.Значение;
			Если Обработка[КЗ.Ключ] <> КЗ.Значение Тогда
				ВызватьИсключение "Не удалось установить реквизит """+КЗ.Ключ+""" при иницилизации обработки выгрузки/загрузки данных.";
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция API(Кластер=Неопределено) Экспорт
	
	_Кластер = Кластер;
	Если Не ЗначениеЗаполнено(_Кластер) Тогда
		_Кластер = Справочники.КафкаКластеры.ПоУмолчанию;
	КонецЕсли;
	
	API = КафкаПереопределяемый.API();
	
	Если Не ЗначениеЗаполнено(_Кластер) Тогда
		API.Инициализировать();
	Иначе
		API.Инициализировать(_Кластер.ПроксиАдрес, _Кластер.ПроксиПользователь, _Кластер.ПроксиПароль, _Кластер.ПроксиТаймаут);
	КонецЕсли;
	
	Возврат API;
	
КонецФункции

Функция ШинаИнфо(ШинаСсылка) Экспорт
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ШиныОбмена.Ссылка КАК Ссылка,
	|	ШиныОбмена.ПометкаУдаления КАК ПометкаУдаления,
	|	ШиныОбмена.Родитель КАК Родитель,
	|	ШиныОбмена.ЭтоГруппа КАК ЭтоГруппа,
	|	ШиныОбмена.Наименование КАК Наименование,
	|	ШиныОбмена.Кластер КАК Кластер,
	|	ШиныОбмена.Вид КАК Вид,
	|	ШиныОбмена.Тема КАК Тема,
	|	ШиныОбмена.Узел КАК Узел,
	|	ШиныОбмена.ОбменПоРасписанию КАК ОбменПоРасписанию,
	|	ШиныОбмена.ОбменРасписание КАК ОбменРасписание,
	|	ШиныОбмена.Обработка КАК Обработка,
	|	ШиныОбмена.ОтправкаПараллелизм КАК ОтправкаПараллелизм,
	|	ШиныОбмена.ОтправкаБлокироватьТаблицуРегистрации КАК ОтправкаБлокироватьТаблицуРегистрации,
	|	ШиныОбмена.ПриемВРеальномВремени КАК ПриемВРеальномВремени,
	|	ШиныОбмена.ПриемДлительность КАК ПриемДлительность,
	|	ШиныОбмена.ПриемТаймаутОжидания КАК ПриемТаймаутОжидания,
	|	ШиныОбмена.КлиентТаймаут КАК КлиентТаймаут,
	|	ШиныОбмена.ПриемОднимРЗ КАК ПриемОднимРЗ,
	|	ЕСТЬNULL(ЕСТЬNULL(ШиныОбмена.ПользовательРЗ, ШиныОбмена.Родитель.ПользовательРЗ), """") КАК ПользовательРЗ
	|ИЗ
	|	Справочник.КафкаШиныОбмена КАК ШиныОбмена
	|ГДЕ
	|	ШиныОбмена.Ссылка = &Ссылка");
	Запрос.УстановитьПараметр("Ссылка", ШинаСсылка);
	РезультатЗапроса = Запрос.ВыполнитьПакет();
	
	Если РезультатЗапроса[0].Пустой() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Структура;
	
	Шапка = РезультатЗапроса[0].Выгрузить()[0];
	Для Каждого Колонка Из РезультатЗапроса[0].Колонки Цикл
		Результат.Вставить(Колонка.Имя, Шапка[Колонка.Имя]);
	КонецЦикла;
		
	Результат.ОбменРасписание = Результат.ОбменРасписание.Получить();
	//Если Результат.ОбменРасписание = Неопределено Тогда
	//	Результат.ОбменРасписание = Справочники.КафкаШиныОбмена.ОбменРасписаниеПоУмолчанию();
	//КонецЕсли;
	
	//Если Не ЗначениеЗаполнено(Результат.ОтправкаПараллелизм) Тогда
	//	Результат.ОтправкаПараллелизм = 4;
	//КонецЕсли;
	
	Если КафкаПовтИсп.ЭтоБэкап() Тогда
		Результат.Тема = "test-" + Результат.Тема;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Процедура ОбновитьРегламентныеЗадания(ШинаСсылка, Удалить=Неопределено) Экспорт
		
	МетаданныеОтправка = Метаданные.РегламентныеЗадания.КафкаВыгрузка;
	МетаданныеПрием = Метаданные.РегламентныеЗадания.КафкаЗагрузка;
	
	ШинаИнфо = ШинаИнфо(ШинаСсылка);
	
	Если Удалить = Неопределено Тогда
		Удалить = ШинаИнфо.ПометкаУдаления;
	КонецЕсли;
		
	МассивЗаданийОтправка = Новый Массив;
	м = РегламентныеЗадания.ПолучитьРегламентныеЗадания(Новый Структура("Метаданные", МетаданныеОтправка));
	Для Каждого Задание Из м Цикл
		Если Задание.Параметры=Неопределено Или Задание.Параметры.Количество()=0 Или ТипЗнч(Задание.Параметры[0])<>Тип("СправочникСсылка.КафкаШиныОбмена") Или Не ЗначениеЗаполнено(Задание.Параметры[0]) Тогда
			УдалитьРегламентноеЗадание(Задание);
		ИначеЕсли Задание.Параметры[0] = ШинаСсылка Тогда
			МассивЗаданийОтправка.Добавить(Задание);
		КонецЕсли;
	КонецЦикла;
	
	МассивЗаданийПрием = Новый Массив;
	м = РегламентныеЗадания.ПолучитьРегламентныеЗадания(Новый Структура("Метаданные", МетаданныеПрием));
	Для Каждого Задание Из м Цикл
		Если Задание.Параметры=Неопределено Или Задание.Параметры.Количество()=0 Или ТипЗнч(Задание.Параметры[0])<>Тип("СправочникСсылка.КафкаШиныОбмена") Или Не ЗначениеЗаполнено(Задание.Параметры[0]) Тогда
			УдалитьРегламентноеЗадание(Задание);
		ИначеЕсли Задание.Параметры[0] = ШинаСсылка Тогда
			МассивЗаданийПрием.Добавить(Задание);
		КонецЕсли;
	КонецЦикла;
	
	Если Удалить Или Не ШинаИнфо.ОбменПоРасписанию Тогда
		Для Каждого Задание Из МассивЗаданийОтправка Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		Для Каждого Задание Из МассивЗаданийПрием Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		Возврат;
	КонецЕсли;
	
	Если ШинаИнфо.Вид = "Приемник" Тогда
		
		Для Каждого Задание Из МассивЗаданийПрием Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		
		Задание = Неопределено;
		Если МассивЗаданийОтправка.Количество() > 0 Тогда
			Задание = МассивЗаданийОтправка.Получить(0);
			МассивЗаданийОтправка.Удалить(0);
		КонецЕсли;
			
		ОбновитьРегламентноеЗадание(Задание, МетаданныеОтправка, ШинаИнфо);
					
		Для Каждого Задание Из МассивЗаданийОтправка Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		
	ИначеЕсли ШинаИнфо.Вид = "Источник" Тогда
		
		Для Каждого Задание Из МассивЗаданийОтправка Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		
		Если ШинаИнфо.ПриемОднимРЗ Тогда
			
			Задание = Неопределено;
			//Если МассивЗаданийПрием.Количество() > 0 Тогда
			//	Задание = МассивЗаданийПрием.Получить(0);
			//	МассивЗаданийПрием.Удалить(0);
			//КонецЕсли;
			
			ОбновитьРегламентноеЗадание(Задание, МетаданныеПрием, ШинаИнфо);
			
		Иначе
			
			Кафка = API(ШинаИнфо.Кластер);
			
			Операция = "Обновление регламентных заданий шины """+ШинаИнфо.Наименование+"""";
			Конфигурация = Справочники.КафкаШиныОбмена.КафкаКонфигурация(ШинаИнфо.Ссылка);
			Admin = Кафка.AdminCreate(Операция, Конфигурация);
			Если Admin = Неопределено Тогда
				ВызватьИсключение Кафка.ОписаниеОшибки;
			КонецЕсли;
			
			Попытка
				Md = Кафка.AdminGetMetadata(Admin.Id, Admin.Token, ШинаИнфо.Тема);
				Кафка.AdminRelease(Admin.Id, Admin.Token);
			Исключение
				Кафка.AdminRelease(Admin.Id, Admin.Token);
				ВызватьИсключение;
			КонецПопытки;
			
			Если Md = Неопределено Тогда
				ВызватьИсключение Кафка.ОписаниеОшибки;
			КонецЕсли;
			
			TopicMd = Md.Topics[0];
			Для Каждого PartitionMd Из TopicMd.Partitions Цикл
				
				ПодходящееЗадание = Неопределено;
				Для индекс = 0 По МассивЗаданийПрием.ВГраница() Цикл
					Задание = МассивЗаданийПрием[индекс];
					Если Задание.Параметры.Количество()>=2 И Задание.Параметры[1]=PartitionMd.Partition Тогда
						ПодходящееЗадание = Задание;
						МассивЗаданийПрием.Удалить(индекс);
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				ОбновитьРегламентноеЗадание(ПодходящееЗадание, МетаданныеПрием, ШинаИнфо, PartitionMd.Partition);
				
			КонецЦикла;
			
		КонецЕсли;
						
		Для Каждого Задание Из МассивЗаданийПрием Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		
	Иначе
		ВызватьИсключение "Неизвестный вид шины: " + ШинаИнфо.Вид;
	КонецЕсли;
	
КонецПроцедуры
Функция ОбновитьРегламентноеЗадание(Задание, ЗаданиеМетаданные, ШинаИнфо, Раздел=Неопределено)
	
	Если Задание = Неопределено Тогда
		Задание = РегламентныеЗадания.СоздатьРегламентноеЗадание(ЗаданиеМетаданные);
	КонецЕсли;
	
	Параметры = Новый Массив;
	Параметры.Добавить(ШинаИнфо.Ссылка);
	Если ЗаданиеМетаданные = Метаданные.РегламентныеЗадания.КафкаЗагрузка Тогда
		Если Раздел = Неопределено Тогда
			Параметры.Добавить(Неопределено);
		Иначе
			Параметры.Добавить(Раздел);
			РазделСтрока = Формат(Раздел, "ЧН=0; ЧГ=0");
		КонецЕсли;
	КонецЕсли;
	
	Задание.Параметры = Параметры;
	Задание.Наименование = ЗаданиеМетаданные.Синоним+": "+ШинаИнфо.Наименование+?(Раздел=Неопределено, "", " ("+РазделСтрока+")");
	Задание.Ключ = Строка(ШинаИнфо.Ссылка.УникальныйИдентификатор()) + ?(Раздел=Неопределено, "", "_"+РазделСтрока);
	Задание.Расписание = ШинаИнфо.ОбменРасписание;
	Задание.Использование = Не ШинаИнфо.ПометкаУдаления;
	Задание.ИмяПользователя = ШинаИнфо.ПользовательРЗ;
	Задание.Записать();
	
КонецФункции
Процедура УдалитьРегламентноеЗадание(РегламентноеЗадание)
	
	РегламентноеЗадание.Удалить();
	
	Отбор = Новый Структура;
	Отбор.Вставить("РегламентноеЗадание", РегламентноеЗадание);
	Отбор.Вставить("Состояние", СостояниеФоновогоЗадания.Активно);
	
	АктивныеФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(Отбор);
		
	Для Каждого ФоновоеЗадание Из АктивныеФоновыеЗадания Цикл
		ФоновоеЗадание.Отменить();
	КонецЦикла;
	
КонецПроцедуры

Функция Тема(ИсходнаяТема) Экспорт
		
	Если КафкаПовтИсп.ЭтоБэкап() Тогда
		Возврат "test-" + ИсходнаяТема;
	КонецЕсли;
	
	Возврат ИсходнаяТема;
	
КонецФункции

Процедура ПолучитьСмещенияТемыВФоне(Кластер, Тема, АдресРезультата=Неопределено) Экспорт
	
	Кафка = API(Кластер);
	
	Операция = "Получение смещений темы """+Тема+"""";
	Конфигурация = Справочники.КафкаКластеры.КафкаКонфигурация(Кластер);
	Результат = Кафка.ПолучитьСмещенияТемы(Операция, Конфигурация, Тема);
	
	Если Результат <> Неопределено Тогда
		ОписаниеРезультата = Новый Структура("Успех, Результат", Истина, Результат);
	Иначе
		ОписаниеРезультата = Новый Структура("Успех, ОписаниеОшибки", Ложь, Кафка.ОписаниеОшибки);
	КонецЕсли;
	
	ПоместитьВоВременноеХранилище(ОписаниеРезультата, АдресРезультата);
	
КонецПроцедуры

#КонецОбласти
