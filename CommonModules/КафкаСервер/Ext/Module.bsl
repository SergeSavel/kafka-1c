#Область Выгрузка

Процедура ВыгрузитьРегламент(Шина) Экспорт
	
	Если КафкаПовтИсп.ЭтоБэкап() И Не КафкаПереопределяемый.РазрешенОбменБэкапов() Тогда
		ТекстСообщения = "Обмен бэкапов запрещен. Выгрузка не будет запущена.";
		КафкаКлиентСервер.СообщитьПользователю(ТекстСообщения);
		ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+Шина.Наименование, УровеньЖурналаРегистрации.Предупреждение, , , ТекстСообщения);
		Возврат;
	КонецЕсли;
		
	Выгрузить(Шина);
	
КонецПроцедуры

Процедура Выгрузить(Шина) Экспорт
	
	Если Не ЗначениеЗаполнено(Шина) Тогда
		ВызватьИсключение "Не заполнена шина. Выгрузка невозможна.";
	КонецЕсли;
	
	ШинаИнфо = ШинаИнфо(Шина);
		
	Если Не ЗначениеЗаполнено(ШинаИнфо.Узел) Тогда
		ВызватьИсключение "Не заполнен узел шины. Выгрузка невозможна.";
	КонецЕсли;
					
	Изменения = ПолучитьИзменения(ШинаИнфо.Узел, ШинаИнфо.ОтправкаБлокироватьТаблицуРегистрации);
	Если Изменения.Количество() = 0 Тогда
		Возврат; // нечего выгружать
	КонецЕсли;
	
	Обработка = КафкаПереопределяемый.ПолучитьОбработку(ШинаИнфо);
	
	// Установим реквизиты обработки.
	ПотенциальныеРеквизитыОбработки = Новый Структура;
	ПотенциальныеРеквизитыОбработки.Вставить("Узел", ШинаИнфо.Узел);
	ПотенциальныеРеквизитыОбработки.Вставить("Шина", ШинаИнфо.Ссылка);
	УстановитьРеквизитыОбработки(Обработка, ПотенциальныеРеквизитыОбработки);
	
	Заголовки = Новый Структура;
	
	// Проверка разрешений на выгрузку для текущего узла.
	Если Не Обработка.ПередВыгрузкойУзла(Заголовки) Тогда
		Возврат;
	КонецЕсли;
	
	ВыгружаемыеТаблицы = Обработка.ВыгружаемыеТаблицы();
	
	Параллелизм = ИнициализироватьПараллелизм(ШинаИнфо.ОтправкаПараллелизм);
	ПредПорядок = Неопределено;
	ПредПакетныйРежим = Неопределено;
	
	Для Каждого ВыгружаемаяТаблица Из ВыгружаемыеТаблицы Цикл
				
		РезультатЗапросаИзменения = Изменения.Получить(ВыгружаемаяТаблица.ПолноеИмя);
		Если РезультатЗапросаИзменения = Неопределено Тогда
			Продолжить; // нечего выгружать по текущей таблице
		КонецЕсли;
		
		// Перед началом выгрузки данных нового порядка дожидаемся завершения выгрузки данных старого порядка.
		Если ПредПорядок <> ВыгружаемаяТаблица.Порядок Тогда
			ДождатьсяЗавершенияВсехПотоков(Параллелизм);
		КонецЕсли;
		
		ПредПорядок = ВыгружаемаяТаблица.Порядок;
		ПредПакетныйРежим = ВыгружаемаяТаблица.ПакетныйРежим;
		
		Если ВыгружаемаяТаблица.ПакетныйРежим Тогда
			Параллелизм.РазмерПакета = ВыгружаемаяТаблица.РазмерПакета;
		Иначе
			Если ЗначениеЗаполнено(ВыгружаемаяТаблица.РазмерПакета) Тогда
				Параллелизм.РазмерПакета = ВыгружаемаяТаблица.РазмерПакета;
			Иначе
				Параллелизм.РазмерПакета = 250;
			КонецЕсли;
		КонецЕсли;
		
		Если ВыгружаемаяТаблица.ПакетныйРежим Тогда
			ВыгрузитьТаблицуПакетно(ШинаИнфо, Обработка, ВыгружаемаяТаблица.ПолноеИмя, РезультатЗапросаИзменения, Заголовки, Параллелизм);
		Иначе
			ВыгрузитьТаблицуПообъектно(ШинаИнфо, Обработка, ВыгружаемаяТаблица.ПолноеИмя, РезультатЗапросаИзменения, Заголовки, Параллелизм);
		КонецЕсли;
				
	КонецЦикла;
		
	ДождатьсяЗавершенияВсехПотоков(Параллелизм);
	
	Обработка.ПослеВыгрузкиУзла();
	
КонецПроцедуры

Функция ПолучитьИзменения(Узел, Блокировать=Ложь)
		
	МассивТекстЗапроса = Новый Массив;
	МассивИменаТаблиц  = Новый Массив;
	
	СоставТаблиц = Узел.Метаданные().Состав;
	
	Если Блокировать Тогда
		Блокировка = Новый БлокировкаДанных;
	КонецЕсли;
	
	Для Каждого ЭлементСостава Из СоставТаблиц Цикл
		ТаблицаИнфо = КафкаПовтИсп.ОписаниеТаблицы(ЭлементСостава.Метаданные.ПолноеИмя());
		
		Если ТаблицаИнфо.ЭтоКонстанта Тогда
			МассивТекстЗапроса.Добавить(
			"ВЫБРАТЬ
			|	ИСТИНА
			|ИЗ
			|	" + ТаблицаИнфо.ПолноеИмя + ".Изменения
			|ГДЕ
			|	Узел = &Узел"); 
		ИначеЕсли ТаблицаИнфо.ЭтоСсылочныйОбъект Тогда
			МассивТекстЗапроса.Добавить(
			"ВЫБРАТЬ
			|	Изменения.Ссылка,
			|	ВЫБОР
			|		КОГДА ОсновнаяТаблица.Ссылка ЕСТЬ NULL 
			|			ТОГДА ИСТИНА
			|		ИНАЧЕ ЛОЖЬ
			|	КОНЕЦ КАК ЭтоУдаление
			|ИЗ
			|	" + ТаблицаИнфо.ПолноеИмя + ".Изменения КАК Изменения
			|		ЛЕВОЕ СОЕДИНЕНИЕ " + ТаблицаИнфо.ПолноеИмя + " КАК ОсновнаяТаблица
			|		ПО Изменения.Ссылка = ОсновнаяТаблица.Ссылка
			|ГДЕ
			|	Изменения.Узел = &Узел"); 
		Иначе
			СтрокаИзмерения = ?(ТаблицаИнфо.КлючевыеПоля.Количество()=0, "ИСТИНА", СтрСоединить(ТаблицаИнфо.КлючевыеПоля, ","));
			МассивТекстЗапроса.Добавить(
			"ВЫБРАТЬ
			|	" + СтрокаИзмерения + "
			|ИЗ
			|	" + ТаблицаИнфо.ПолноеИмя + ".Изменения
			|ГДЕ
			|	Узел = &Узел");
		КонецЕсли;
		
		МассивИменаТаблиц.Добавить(ТаблицаИнфо.ПолноеИмя);
		
		Если Блокировать Тогда
			ЭлементБлокировки = Блокировка.Добавить(ТаблицаИнфо.ПолноеИмя+?(ТаблицаИнфо.ЭтоПодчиненныйРегистр Или ТаблицаИнфо.ЭтоПоследовательность, ".НаборЗаписей", ""));
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		КонецЕсли;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = СтрСоединить(МассивТекстЗапроса, Символы.ПС+";"+Символы.ПС);
	Запрос.УстановитьПараметр("Узел", Узел);
	
	Если Блокировать Тогда
		
		КоличествоПопыток = 10;
		Пока Истина Цикл
			КоличествоПопыток = КоличествоПопыток - 1;
			
			НачатьТранзакцию();
			
			Попытка
				
				Блокировка.Заблокировать();
				
				МассивРезультаты = Запрос.ВыполнитьПакет();
				
				ЗафиксироватьТранзакцию();
				
				Прервать;
			Исключение
				ИнформацияОбОшибке = ИнформацияОбОшибке();
							
				ОтменитьТранзакцию();
				
				Если КоличествоПопыток > 0 Тогда
					ОписаниеОшибки = КафкаКлиентСервер.КорневаяИнформацияОбОшибке(ИнформацияОбОшибке).Описание;
					ОписаниеОшибкиНРег = НРег(ОписаниеОшибки);
					Если Найти(ОписаниеОшибкиНРег, "блокиров")>0 Или Найти(ОписаниеОшибкиНРег, "lock")>0 Тогда
						Продолжить;
					КонецЕсли;
				КонецЕсли;
					
				ВызватьИсключение;
			КонецПопытки
		КонецЦикла;
		
	Иначе
		
		МассивРезультаты = Запрос.ВыполнитьПакет();
		
	КонецЕсли;
		
	Результат = Новый Соответствие;
	Для индекс = 0 По МассивИменаТаблиц.ВГраница() Цикл
		РезультатЗапроса = МассивРезультаты[индекс];
		Если Не РезультатЗапроса.Пустой() Тогда
			Результат.Вставить(МассивИменаТаблиц[индекс], РезультатЗапроса);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура ВыгрузитьТаблицуПообъектно(ШинаИнфо, Обработка, Таблица, РезультатЗапросаИзменения, ОбщиеЗаголовки, Параллелизм)
		
	// Скопируем общие заголовки.
	Заголовки = Новый Структура;
	Для Каждого КЗ Из ОбщиеЗаголовки Цикл
		Заголовки.Вставить(КЗ.Ключ, КЗ.Значение);
	КонецЦикла;
	
	ТаблицаИнфо = КафкаПовтИсп.ОписаниеТаблицы(Таблица);
	
	Если Не Обработка.ПередВыгрузкойТаблицы(ТаблицаИнфо, Заголовки) Тогда
		Возврат;
	КонецЕсли;
								
	ИзмененияВыборка = РезультатЗапросаИзменения.Выбрать();
	
	ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
			УровеньЖурналаРегистрации.Примечание, ШинаИнфо.Узел.Метаданные(), ШинаИнфо.Узел,
			"Начата асинхронная отправка "+ИзмененияВыборка.Количество()+" объектов таблицы '"+Таблица+"'.");
			
	ТаблицаПакета = Неопределено;	
			
	// Обходим все измененные/удаленные объекты.
	Пока ИзмененияВыборка.Следующий() Цикл
		
		// В одном и том же пакете могут присутствовать изменения из разных таблиц. Это необходимо учитывать.
		Если Параллелизм.ТекущийПакет = Неопределено Тогда
			Параллелизм.ТекущийПакет = Новый Структура("Размер, Состав", 0, Новый Массив);
			ТаблицаПакета = Неопределено;
		КонецЕсли;					
		
		Если ТаблицаПакета = Неопределено Тогда
			Данные = Новый ТаблицаЗначений;
			Для Каждого Колонка Из РезультатЗапросаИзменения.Колонки Цикл
				Данные.Колонки.Добавить(Колонка.Имя);
			КонецЦикла;
			
			ТаблицаПакета = Новый Структура("ТаблицаИнфо, Заголовки, Данные", ТаблицаИнфо, Заголовки, Данные);
			Параллелизм.ТекущийПакет.Состав.Добавить(ТаблицаПакета);
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(ТаблицаПакета.Данные.Добавить(), ИзмененияВыборка);
		Параллелизм.ТекущийПакет.Размер = Параллелизм.ТекущийПакет.Размер + 1;
		
		Если Параллелизм.ТекущийПакет.Размер >= Параллелизм.РазмерПакета Тогда
			ВыгрузитьПообъектно(ШинаИнфо, Обработка, Параллелизм);
		КонецЕсли;
		
	КонецЦикла;
	
	// !!! Возможно, будет изменено, т.к. исключает возможность выгрузки разных объектов в одном пакете.
	// Если при пообъектной выгрузке остался "хвост" невыгруженных данных, довыгружаем его.
	Если Параллелизм.ТекущийПакет <> Неопределено Тогда
		ВыгрузитьПообъектно(ШинаИнфо, Обработка, Параллелизм);
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
			УровеньЖурналаРегистрации.Примечание, ШинаИнфо.Узел.Метаданные(), ШинаИнфо.Узел,
			"Завершена асинхронная отправка "+ИзмененияВыборка.Количество()+" объектов таблицы '"+Таблица+"'.");
	
КонецПроцедуры

Процедура ВыгрузитьПообъектно(ШинаИнфо, Обработка, Параллелизм)
	
	ДождатьсяОсвобожденияПулаПотоков(Параллелизм);	
		
	Если Параллелизм.МаксСтепень < 2 Тогда
		// Выгрузим пакет в этом же сеансе.
		
		ВыгрузитьПообъектноЭтотСеанс(ШинаИнфо, Обработка, Параллелизм.ТекущийПакет.Состав);
		
    Иначе
		// Выгрузим пакет в отдельном фоновом сеансе.
		
		Параллелизм.ПотокиСчетчик = Параллелизм.ПотокиСчетчик + 1;
		
		ПараметрыФЗ = Новый Массив;
		ПараметрыФЗ.Добавить(ШинаИнфо);
		ПараметрыФЗ.Добавить(Параллелизм.ТекущийПакет.Состав);
		
		ФЗ = ФоновыеЗадания.Выполнить("КафкаСервер.ВыгрузитьПообъектноОтдельныйСеанс", ПараметрыФЗ, ,
				"Поток выгрузки данных в шину '"+ШинаИнфо.Наименование+"' № "+Параллелизм.ПотокиСчетчик);
				
		Параллелизм.Потоки.Добавить(ФЗ);
		
	КонецЕсли;
	
	Параллелизм.ТекущийПакет = Неопределено;
	
КонецПроцедуры

Процедура ВыгрузитьПообъектноОтдельныйСеанс(ШинаИнфо, Состав) Экспорт
	
	Обработка = КафкаПереопределяемый.ПолучитьОбработку(ШинаИнфо);
	Обработка.Узел = ШинаИнфо.Узел;
	
	ВыгрузитьПообъектноЭтотСеанс(ШинаИнфо, Обработка, Состав);
	
КонецПроцедуры

Процедура ВыгрузитьПообъектноЭтотСеанс(ШинаИнфо, Обработка, Состав)
	
	// Инициализируем соединение с Кафкой.
	Кафка = API(ШинаИнфо.Кластер);
	
	Обработка.ПередВыгрузкойПакета(Кафка);
		
	Для Каждого ЭлементСостава Из Состав Цикл
		
		ТаблицаИнфо = ЭлементСостава.ТаблицаИнфо;
		ОбщиеЗаголовки = ЭлементСостава.Заголовки;
		
		Для Каждого СтрокаПакета Из ЭлементСостава.Данные Цикл
			
			// Скопируем общие заголовки.
			Заголовки = Новый Структура;
			Для Каждого КЗ Из ОбщиеЗаголовки Цикл
				Заголовки.Вставить(КЗ.Ключ, КЗ.Значение);
			КонецЦикла;
			
			// Итерацию выгрузки каждого объекта выполняем в отдельной транзакции.
			// Внутри транзакции только необходимый минимум действий.
			НачатьТранзакцию();
			
			// Устанавливаем разделяемую блокировку 
			Блокировка = Новый БлокировкаДанных;
			ЭлементБлокировки = Блокировка.Добавить(ТаблицаИнфо.ПолноеИмя+?(ТаблицаИнфо.ЭтоПодчиненныйРегистр Или ТаблицаИнфо.ЭтоПоследовательность, ".НаборЗаписей", ""));
			Для Каждого Поле Из ТаблицаИнфо.КлючевыеПоля Цикл
				ЭлементБлокировки.УстановитьЗначение(Поле, СтрокаПакета[Поле]);
			КонецЦикла;
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
			Блокировка.Заблокировать();
			
			// Читаем объект.
			Если ТаблицаИнфо.ЭтоКонстанта Тогда
				
				Объект = Константы[ТаблицаИнфо.Имя].СоздатьМенеджерЗначения();
				Объект.Прочитать();
			
			ИначеЕсли ТаблицаИнфо.ЭтоСсылочныйОбъект Тогда
				
				Если СтрокаПакета.ЭтоУдаление Тогда
					Объект = Новый УдалениеОбъекта(СтрокаПакета.Ссылка);
				Иначе // Это обычное изменение
					Объект = СтрокаПакета.Ссылка.ПолучитьОбъект();
				КонецЕсли;
					
			Иначе // Это регистр или последовательность
			
				РегистрМенеджер = КафкаПовтИсп.МенеджерТаблицы(ТаблицаИнфо.ПолноеИмя);
				
				Объект = РегистрМенеджер.СоздатьНаборЗаписей();
				Для Каждого Поле Из ТаблицаИнфо.КлючевыеПоля Цикл
					Объект.Отбор[Поле].Установить(СтрокаПакета[Поле]);
				КонецЦикла;
				Объект.Прочитать();
				
			КонецЕсли;
						
			// Разрегистрируем объект.
			ПланыОбмена.УдалитьРегистрациюИзменений(ШинаИнфо.Узел, Объект);
			
			ВыгружатьОбъект = Обработка.ПередВыгрузкойОбъекта(Объект, ТаблицаИнфо, Заголовки);
			Если ВыгружатьОбъект Тогда
			
				// Сериализуем объект
				СхемаОбъекта = Неопределено; // Для бинарной сериализации.
				СериализованныйОбъект = Обработка.СериализоватьОбъект(Объект, ТаблицаИнфо, Заголовки, СхемаОбъекта);
				
				// Ключ сообщения нужен для правильного распределения объектов по разделам (партициям).
				// По умолчанию этот ключ одинаков для ссылочных объектов и зависимых наборов записей.
				// Таким образом регистраторы и их наборы записей попадут в одну партицию и будут прочитаны в правильном порядке.
				СхемаКлюча = Неопределено; // Для бинарной сериализации.
				КлючСообщения = Обработка.КлючОбъекта(Объект, ТаблицаИнфо, СхемаКлюча);
								
				// Отправляем данные. Это должно быть самое последнее действие в транзакции.
				DeliveryResult = Кафка.Produce(ШинаИнфо.Тема, , СериализованныйОбъект, КлючСообщения, Заголовки, СхемаОбъекта, СхемаКлюча);
				Если DeliveryResult = Неопределено Тогда
					ОтменитьТранзакцию();
					ВызватьИсключение Кафка.ОписаниеОшибки;
				ИначеЕсли DeliveryResult.Status <> "Persisted" Тогда
					ОтменитьТранзакцию();
					ВызватьИсключение "Не удалось отправить сообщение. Статус доставки: '"+DeliveryResult.Status+"'."; // TODO: Более подробная причина.
				КонецЕсли;
									
			КонецЕсли;
						
			ЗафиксироватьТранзакцию();
			
			Если ВыгружатьОбъект Тогда
				Обработка.ПослеВыгрузкиОбъекта(Объект, ТаблицаИнфо, DeliveryResult);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ВыгрузитьТаблицуПакетно(ШинаИнфо, Обработка, Таблица, РезультатЗапросаИзменения, ОбщиеЗаголовки, Параллелизм)
	
	Если Не ЗначениеЗаполнено(Параллелизм.РазмерПакета) Тогда
		ВызватьИсключение "Не указан размер пакета для таблицы """+Таблица+""".";
	КонецЕсли;
	
	// Скопируем общие заголовки.
	Заголовки = Новый Структура;
	Для Каждого КЗ Из ОбщиеЗаголовки Цикл
		Заголовки.Вставить(КЗ.Ключ, КЗ.Значение);
	КонецЦикла;
	
	ТаблицаИнфо = КафкаПовтИсп.ОписаниеТаблицы(Таблица);
	
	Если Не Обработка.ПередВыгрузкойТаблицы(ТаблицаИнфо, Заголовки) Тогда
		Возврат;
	КонецЕсли;
								
	ИзмененияВыборка = РезультатЗапросаИзменения.Выбрать();
	
	ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
			УровеньЖурналаРегистрации.Примечание, ШинаИнфо.Узел.Метаданные(), ШинаИнфо.Узел,
			"Начата асинхронная отправка "+ИзмененияВыборка.Количество()+" объектов таблицы '"+Таблица+"'.");
			
	Если Параллелизм.ТекущийПакет <> Неопределено Тогда // Временно.
		ВызватьИсключение "Обнаружены неотправленные данные предыдущей таблицы.";	
	КонецЕсли;			
	
	ТекущийПакет = Неопределено;
	
	// Обходим все измененные/удаленные объекты.
	Пока ИзмененияВыборка.Следующий() Цикл
		
		Если Параллелизм.ТекущийПакет = Неопределено Тогда
			Данные = Новый ТаблицаЗначений;
			Для Каждого Колонка Из РезультатЗапросаИзменения.Колонки Цикл
				Данные.Колонки.Добавить(Колонка.Имя);
			КонецЦикла;
			ТекущийПакет = Новый Структура("Размер, ТаблицаИнфо, Заголовки, Данные", 0, ТаблицаИнфо, Заголовки, Данные);
			Параллелизм.ТекущийПакет = ТекущийПакет;
		КонецЕсли;					
				
		ЗаполнитьЗначенияСвойств(ТекущийПакет.Данные.Добавить(), ИзмененияВыборка);
		ТекущийПакет.Размер = ТекущийПакет.Размер + 1;
		
		Если ТекущийПакет.Размер >= Параллелизм.РазмерПакета Тогда
			ВыгрузитьПакетно(ШинаИнфо, Обработка, Параллелизм);
		КонецЕсли;
		
	КонецЦикла;
	
	// Если при пакетной выгрузке остался "хвост" невыгруженных данных, довыгружаем его.
	Если Параллелизм.ТекущийПакет <> Неопределено Тогда
		ВыгрузитьПакетно(ШинаИнфо, Обработка, Параллелизм);
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
			УровеньЖурналаРегистрации.Примечание, ШинаИнфо.Узел.Метаданные(), ШинаИнфо.Узел,
			"Завершена асинхронная отправка "+ИзмененияВыборка.Количество()+" объектов таблицы '"+Таблица+"'.");
	
КонецПроцедуры

Процедура ВыгрузитьПакетно(ШинаИнфо, Обработка, Параллелизм)
	
	ДождатьсяОсвобожденияПулаПотоков(Параллелизм);	
		
	Если Параллелизм.МаксСтепень < 2 Тогда
		// Выгрузим пакет в этом же сеансе.
		
		ВыгрузитьПакетноЭтотСеанс(ШинаИнфо, Обработка, Параллелизм.ТекущийПакет);
		
    Иначе
		// Выгрузим пакет в отдельном фоновом сеансе.
		
		Параллелизм.ПотокиСчетчик = Параллелизм.ПотокиСчетчик + 1;
		
		ПараметрыФЗ = Новый Массив;
		ПараметрыФЗ.Добавить(ШинаИнфо);
		ПараметрыФЗ.Добавить(Параллелизм.ТекущийПакет);
		
		ФЗ = ФоновыеЗадания.Выполнить("КафкаСервер.ВыгрузитьПакетноОтдельныйСеанс", ПараметрыФЗ, ,
				"Поток выгрузки данных в шину '"+ШинаИнфо.Наименование+"' № "+Параллелизм.ПотокиСчетчик);
				
		Параллелизм.Потоки.Добавить(ФЗ);
		
	КонецЕсли;
	
	Параллелизм.ТекущийПакет = Неопределено;
	
КонецПроцедуры

Процедура ВыгрузитьПакетноОтдельныйСеанс(ШинаИнфо, Пакет) Экспорт
	
	Обработка = КафкаПереопределяемый.ПолучитьОбработку(ШинаИнфо);
	Обработка.Узел = ШинаИнфо.Узел;
	
	ВыгрузитьПакетноЭтотСеанс(ШинаИнфо, Обработка, Пакет);
	
КонецПроцедуры

Процедура ВыгрузитьПакетноЭтотСеанс(ШинаИнфо, Обработка, Пакет)
	
	// Инициализируем соединение с Кафкой.
	Кафка = API(ШинаИнфо.Кластер);
	
	Обработка.ПередВыгрузкойПакета(Кафка);
				
	ТаблицаИнфо = Пакет.ТаблицаИнфо;
	ОбщиеЗаголовки = Пакет.Заголовки;
	
	// Скопируем общие заголовки.
	Заголовки = Новый Структура;
	Для Каждого КЗ Из Пакет.Заголовки Цикл
		Заголовки.Вставить(КЗ.Ключ, КЗ.Значение);
	КонецЦикла;
	
	НачатьТранзакцию();
	
	МассивОбъектов = Новый Массив;
	
	Для Каждого СтрокаПакета Из Пакет.Данные Цикл
						
		// Устанавливаем разделяемую блокировку 
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить(ТаблицаИнфо.ПолноеИмя+?(ТаблицаИнфо.ЭтоПодчиненныйРегистр Или ТаблицаИнфо.ЭтоПоследовательность, ".НаборЗаписей", ""));
		Для Каждого Поле Из ТаблицаИнфо.КлючевыеПоля Цикл
			ЭлементБлокировки.УстановитьЗначение(Поле, СтрокаПакета[Поле]);
		КонецЦикла;
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		Блокировка.Заблокировать();
		
		// Читаем объект.
		Если ТаблицаИнфо.ЭтоКонстанта Тогда
			
			Объект = Константы[ТаблицаИнфо.Имя].СоздатьМенеджерЗначения();
			Объект.Прочитать();
		
		ИначеЕсли ТаблицаИнфо.ЭтоСсылочныйОбъект Тогда
			
			Если СтрокаПакета.ЭтоУдаление Тогда
				Объект = Новый УдалениеОбъекта(СтрокаПакета.Ссылка);
			Иначе // Это обычное изменение
				Объект = СтрокаПакета.Ссылка.ПолучитьОбъект();
			КонецЕсли;
				
		Иначе // Это регистр или последовательность
		
			РегистрМенеджер = КафкаПовтИсп.МенеджерТаблицы(ТаблицаИнфо.ПолноеИмя);
			
			Объект = РегистрМенеджер.СоздатьНаборЗаписей();
			Для Каждого Поле Из ТаблицаИнфо.КлючевыеПоля Цикл
				Объект.Отбор[Поле].Установить(СтрокаПакета[Поле]);
			КонецЦикла;
			Объект.Прочитать();
			
		КонецЕсли;
					
		// Разрегистрируем объект.
		ПланыОбмена.УдалитьРегистрациюИзменений(ШинаИнфо.Узел, Объект);
		
		ВыгружатьОбъект = Обработка.ПередВыгрузкойОбъекта(Объект, ТаблицаИнфо, Заголовки);
		
		Если ВыгружатьОбъект Тогда
			МассивОбъектов.Добавить(Объект);
		КонецЕсли;
			
	КонецЦикла;
	
	Если МассивОбъектов.Количество() > 0 Тогда
	
		// Сериализуем объект
		СхемаЗначения = Неопределено; // Для бинарной сериализации.
		Значение = Обработка.СериализоватьПакет(МассивОбъектов, ТаблицаИнфо, Заголовки, СхемаЗначения);
		
		СхемаКлюча = Неопределено; // Для бинарной сериализации.
		Ключ = Обработка.КлючПакета(МассивОбъектов, ТаблицаИнфо, СхемаКлюча);
						
		// Отправляем данные. Это должно быть самое последнее действие в транзакции.
		DeliveryResult = Кафка.Produce(ШинаИнфо.Тема, , Значение, Ключ, Заголовки, СхемаЗначения, СхемаКлюча);
		Если DeliveryResult = Неопределено Тогда
			ОтменитьТранзакцию();
			ВызватьИсключение Кафка.ОписаниеОшибки;
		ИначеЕсли DeliveryResult.Status <> "Persisted" Тогда
			ОтменитьТранзакцию();
			ВызватьИсключение "Не удалось отправить сообщение. Статус доставки: '"+DeliveryResult.Status+"'."; // TODO: Более подробная причина.
		КонецЕсли;
		
	КонецЕсли;
		
	ЗафиксироватьТранзакцию();
		
	Если МассивОбъектов.Количество() > 0 Тогда
		Обработка.ПослеВыгрузкиПакета(МассивОбъектов, ТаблицаИнфо, DeliveryResult);
	КонецЕсли;
	
КонецПроцедуры

#Область ВыгрузкаВспомогательныеФункции

Функция ИнициализироватьПараллелизм(МаксСтепень)
		
	Результат = Новый Структура;
	
	Результат.Вставить("МаксСтепень", МаксСтепень);
	Результат.Вставить("Потоки", Новый Массив);
	Результат.Вставить("ПотокиСчетчик", 0);
	Результат.Вставить("РазмерПакета");
	Результат.Вставить("ТекущийПакет");
	
	Возврат Результат;
	
КонецФункции

Процедура ДождатьсяОсвобожденияПулаПотоков(Параллелизм, УчитыватьСтепеньПараллелизма=Истина)
	
	Если УчитыватьСтепеньПараллелизма И Параллелизм.Потоки.Количество()<Параллелизм.МаксСтепень Тогда
		Возврат;
	КонецЕсли;
	
	Параллелизм.Потоки = ФоновыеЗадания.ОжидатьЗавершенияВыполнения(Параллелизм.Потоки);
		
	Колво = Параллелизм.Потоки.Количество();
	Индекс = Колво;
	Пока Индекс > 0 Цикл
		Индекс = Индекс - 1;
		ФЗ = Параллелизм.Потоки[Индекс];
		Если ФЗ.Состояние = СостояниеФоновогоЗадания.Активно Тогда
		ИначеЕсли ФЗ.Состояние = СостояниеФоновогоЗадания.Завершено Тогда
			Параллелизм.Потоки.Удалить(Индекс);
		ИначеЕсли ФЗ.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда
			ОписаниеОшибки = "Один из потоков завершился ошибкой.";
			Если ФЗ.ИнформацияОбОшибке <> Неопределено Тогда
				ОписаниеОшибки = ОписаниеОшибки + Символы.ПС + ПодробноеПредставлениеОшибки(ФЗ.ИнформацияОбОшибке);
			КонецЕсли;
			ВызватьИсключение ОписаниеОшибки;
		ИначеЕсли ФЗ.Состояние = СостояниеФоновогоЗадания.Отменено Тогда
			ВызватьИсключение "Один из потоков был вручную отменен.";
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ДождатьсяЗавершенияВсехПотоков(Параллелизм)
	
	Пока Параллелизм.Потоки.Количество() > 0 Цикл
		ДождатьсяОсвобожденияПулаПотоков(Параллелизм, Ложь)
	КонецЦикла;
		
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область Загрузка

Процедура ЗагрузитьРегламент(Шина, Раздел=Неопределено) Экспорт
	
	Если КафкаПовтИсп.ЭтоБэкап() И Не КафкаПереопределяемый.РазрешенОбменБэкапов() Тогда
		ТекстСообщения = "Обмен бэкапов запрещен. Загрузка не будет запущена.";
		КафкаКлиентСервер.СообщитьПользователю(ТекстСообщения);
		ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+Шина.Наименование, УровеньЖурналаРегистрации.Предупреждение, , , ТекстСообщения);
		Возврат;
	КонецЕсли;
	
	Загрузить(Шина, Раздел);
	
КонецПроцедуры

Процедура Загрузить(Шина, Раздел=Неопределено) Экспорт
	
	МоментСтарта = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	ДатаСтарта = ТекущаяДата();
	
	ШинаИнфо = ШинаИнфо(Шина);
	Если ШинаИнфо = Неопределено Тогда
		ВызватьИсключение "Некорректная шина.";
	КонецЕсли;
	
	// Инициализируем обработку загрузки данных.
	Обработка = КафкаПереопределяемый.ПолучитьОбработку(ШинаИнфо);
	Если Обработка = Неопределено Тогда
		ВызватьИсключение "Не удалось инициализировать обработку обмена для шины """+Шина+""".";
	КонецЕсли;
	
	// Установим реквизиты обработки.
	ПотенциальныеРеквизитыОбработки = Новый Структура;
	ПотенциальныеРеквизитыОбработки.Вставить("Узел", ШинаИнфо.Узел);
	ПотенциальныеРеквизитыОбработки.Вставить("Шина", ШинаИнфо.Ссылка);
	УстановитьРеквизитыОбработки(Обработка, ПотенциальныеРеквизитыОбработки);

	Кафка = API(ШинаИнфо.Кластер);
		
	// Формируем масив разделов, из которых будем читать сообщения.
	Разделы = Новый Массив;
	Если Раздел = Неопределено Тогда
		TopicMetadata = Кафка.GetTopicMetadata(ШинаИнфо.Тема);
		Если TopicMetadata = Неопределено Тогда
			ВызватьИсключение Кафка.ОписаниеОшибки;
		КонецЕсли;
		Для Каждого PartitionMetadata Из TopicMetadata.Partitions Цикл
			Разделы.Добавить(Новый Структура("Topic, Partition", TopicMetadata.Topic, PartitionMetadata.Partition));
		КонецЦикла;
	Иначе
		Разделы.Добавить(Новый Структура("Topic, Partition", ШинаИнфо.Тема, Раздел));
	КонецЕсли;
	
	// Если по каким-то (или всем) разделам загрузка запрещена, удаляем разделы из массива.
	Индекс = Разделы.Количество();
	Пока Индекс > 0 Цикл
		Индекс = Индекс - 1;
		TopicPartition = Разделы[Индекс];
		Если Не Обработка.ПередЗагрузкойРаздела(TopicPartition.Topic, TopicPartition.Partition, Кафка) Тогда
			Разделы.Удалить(Индекс);
		КонецЕсли;
	КонецЦикла;
	Если Разделы.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Инициализируем параметры получателя.
	ConsumerConfig = ПараметрыПолучателя(Шина);
	Если ConsumerConfig.Получить("group.id") = Неопределено Тогда 
		ConsumerConfig.Вставить("group.id", КафкаПовтИсп.ГруппаПолучателей());
	КонецЕсли;
	ConsumerConfig.Вставить("enable.partition.eof", ?(ШинаИнфо.ПриемВРеальномВремени, "false", "true"));
	
	// Создаем экземпляр получателя внутри прокси, который будет читать сообщения для нас.
	Consumer = Кафка.CreateConsumer(ШинаИнфо.ПриемТаймаутПолучателя, ConsumerConfig);
	Если Consumer = Неопределено Тогда
		ВызватьИсключение Кафка.ОписаниеОшибки;
	КонецЕсли;
	
	// Конструкция, гарантирующая удаление экземпляра получателя независимо от того, чем завершится чтение.
	Попытка
		
		Загрузить_(ШинаИнфо, Разделы, Consumer, Кафка, Обработка, МоментСтарта);
		
		Кафка.ReleaseConsumer(Consumer.Id);
		
	Исключение
		Кафка.ReleaseConsumer(Consumer.Id);
		ВызватьИсключение;
	КонецПопытки;
		
КонецПроцедуры
Процедура Загрузить_(ШинаИнфо, ConsumerAssignment, Consumer, Кафка, Обработка, МоментСтарта)
	
	ЕстьНовыеСообщения = Ложь;
	
	СостоянияЧтения = Новый Соответствие;
	
	Для Каждого TopicPartition Из ConsumerAssignment Цикл
				
		// Получаем начальное и конечное смещения раздела.
		PartitionOffsets = Кафка.GetPartitionOffsets(Consumer.Id, TopicPartition.Topic, TopicPartition.Partition, ШинаИнфо.ПриемТаймаутОжидания);
		Если PartitionOffsets = Неопределено Тогда
			ВызватьИсключение Кафка.ОписаниеОшибки;
		КонецЕсли;
		
		// Получаем последнюю зафиксированную позицию чтения.
		ТекущаяПозиция = РегистрыСведений.КафкаПозиции.ПолучитьПозицию(TopicPartition.Topic, TopicPartition.Partition);
		
		// Проверка корректности текущей позиции
		Если ТекущаяПозиция < PartitionOffsets.Low Тогда
			ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
					УровеньЖурналаРегистрации.Предупреждение, , TopicPartition.Topic+":"+Формат(TopicPartition.Partition, "ЧН=0; ЧГ=0"),
					"Начальная позиция раздела ("+Формат(PartitionOffsets.Low, "ЧН=0")+") больше текущей ("+Формат(ТекущаяПозиция, "ЧН=0")+"). Текущая позиция будет скорректирована.");
			ТекущаяПозиция = PartitionOffsets.Low;
		ИначеЕсли ТекущаяПозиция > PartitionOffsets.High Тогда
			ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
					УровеньЖурналаРегистрации.Предупреждение, , TopicPartition.Topic+":"+Формат(TopicPartition.Partition, "ЧН=0; ЧГ=0"),
					"Конечная позиция раздела ("+Формат(PartitionOffsets.High, "ЧН=0")+") меньше текущей ("+Формат(ТекущаяПозиция, "ЧН=0")+"). Текущая позиция будет скорректирована.");
			ТекущаяПозиция = PartitionOffsets.High;
		КонецЕсли;
		
		// Установим начальную позицию, с которой будут прочитаны сообщения раздела.
		TopicPartition.Вставить("Offset", ТекущаяПозиция);
		
		СостоянияЧтенияТопика = СостоянияЧтения.Получить(TopicPartition.Topic);
		Если СостоянияЧтенияТопика = Неопределено Тогда
			СостоянияЧтенияТопика = Новый Соответствие;
			СостоянияЧтения.Вставить(TopicPartition.Topic, СостоянияЧтенияТопика);
		КонецЕсли;
		
		СостояниеЧтенияРаздела = Новый Структура("НачальноеСмещение, КонечноеСмещение, ТекущаяПозиция", PartitionOffsets.Low, PartitionOffsets.High, ТекущаяПозиция);
		СостояниеЧтенияРаздела.Вставить("НачальноеСмещение"	, PartitionOffsets.Low);
		СостояниеЧтенияРаздела.Вставить("КонечноеСмещение"	, PartitionOffsets.High);
		СостояниеЧтенияРаздела.Вставить("ТекущаяПозиция"	, ТекущаяПозиция);
		
		СостоянияЧтенияТопика.Вставить(TopicPartition.Partition, СостояниеЧтенияРаздела);
		
		ЕстьНовыеСообщения = ЕстьНовыеСообщения Или (ТекущаяПозиция<PartitionOffsets.High);
		
	КонецЦикла;
	
	// Если длительность приема равна нулю и нет новых сообщений,
	// нет смысла инициировать получение сообщений.
	Если ЕстьНовыеСообщения Или ШинаИнфо.ПриемДлительность>0 Тогда
		
		ТекущаяУниверсальнаяДатаВМиллисекундах = ТекущаяУниверсальнаяДатаВМиллисекундах();
		Для Каждого TopicPartition Из ConsumerAssignment Цикл
			
			СостояниеЧтенияРаздела = СостоянияЧтения[TopicPartition.Topic][TopicPartition.Partition];
			СостояниеЧтенияРаздела.Вставить("ПолученоСообщенийПослеПоследнейФиксации", 0);
			СостояниеЧтенияРаздела.Вставить("МоментПоследнейФиксации", ТекущаяУниверсальнаяДатаВМиллисекундах);
			
			ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
					УровеньЖурналаРегистрации.Информация, , TopicPartition.Topic+":"+Формат(TopicPartition.Partition, "ЧН=0; ЧГ=0"),
					"Начато чтение раздела. Начальная позиция: "+Формат(СостояниеЧтенияРаздела.ТекущаяПозиция, "ЧН=0")+".");
			
		КонецЦикла;
		
		// Назначим получателя читать сообщения из переданных топиков-разделов
		ConsumerAssignment = Кафка.AssignConsumer(Consumer.Id, ConsumerAssignment);
		Если ConsumerAssignment = Неопределено Тогда
			ВызватьИсключение Кафка.ОписаниеОшибки;
		КонецЕсли;
		
		ОсталосьРазделов = ConsumerAssignment.Количество();
		
		Пока Истина Цикл
			
			// Получим новое сообщение
			Message = Кафка.Consume(Consumer.Id, ШинаИнфо.ПриемТаймаутОжидания);
			
			Если Message = Неопределено Тогда
				ВызватьИсключение Кафка.ОписаниеОшибки;
			КонецЕсли;
			
			Если Message<>Null И Не Message.IsPartitionEOF Тогда

				СостояниеЧтенияРаздела = СостоянияЧтения[Message.Topic][Message.Partition];
				
				Если Message.Offset < СостояниеЧтенияРаздела.ТекущаяПозиция Тогда
					ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
							УровеньЖурналаРегистрации.Предупреждение, , Message.Topic+":"+Формат(Message.Partition, "ЧН=0; ЧГ=0"),
							"Позиция полученного сообщения ("+Формат(Message.Offset, "ЧН=0")+") меньше текущей ("+Формат(СостояниеЧтенияРаздела.ТекущаяПозиция, "ЧН=0")+"). Чтение не будет выполнено.");
					Прервать;
				ИначеЕсли Message.Offset > СостояниеЧтенияРаздела.ТекущаяПозиция Тогда
					ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
							УровеньЖурналаРегистрации.Предупреждение, , Message.Topic+":"+Формат(Message.Partition, "ЧН=0; ЧГ=0"),
							"Позиция полученного сообщения ("+Формат(Message.Offset, "ЧН=0")+") больше текущей ("+Формат(СостояниеЧтенияРаздела.ТекущаяПозиция, "ЧН=0")+").");
				КонецЕсли;
				
				// Обновление состояния чтения текущего раздела.
				СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации = СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации + 1;
				СостояниеЧтенияРаздела.ТекущаяПозиция = Message.Offset + 1;
				
				// Собственно, загрузка самого сообщения.
				Обработка.ЗагрузитьСообщение(Message);
				
			КонецЕсли;
			
			ТекущаяУниверсальнаяДатаВМиллисекундах = ТекущаяУниверсальнаяДатаВМиллисекундах();
			
			Если ШинаИнфо.ПриемДлительность<>0 И ТекущаяУниверсальнаяДатаВМиллисекундах-МоментСтарта>=ШинаИнфо.ПриемДлительность Тогда
				// Завершаем загрузку по истечению максимальной длительности.
				Прервать;
			КонецЕсли;
									
			Если ШинаИнфо.ПриемВРеальномВремени Тогда
				
				// Если долго не получаем новых сообщений, надо периодически проверять наличие незафиксированных позиций.
				Если Message = Null Тогда
					Для Каждого TopicPartition Из ConsumerAssignment Цикл
						СостояниеЧтенияРаздела = СостоянияЧтения[TopicPartition.Topic][TopicPartition.Partition];
						ЗафиксироватьПозициюЧтения(TopicPartition.Topic, TopicPartition.Partition, СостояниеЧтенияРаздела, Обработка);
					КонецЦикла;
				КонецЕсли;
								
			Иначе
				
				Если Message = Null Тогда
					// Завершаем загрузку в случае отсутствия новых сообщений.
					Прервать;
				ИначеЕсли Message.IsPartitionEOF Тогда
					ОсталосьРазделов = ОсталосьРазделов - 1;
					Если ОсталосьРазделов = 0 Тогда
						// От всех разделов были получены маркеры отсутствия новых сообщений. Завершаем чтение.
						Прервать;
					КонецЕсли;
				КонецЕсли;
				
			КонецЕсли;
			
			Если Message<>Null И Не Message.IsPartitionEOF Тогда
				// Фиксируем текущую позицию чтения каждые 500 сообщений или каждые 20 секунд, смотря что наступит раньше.
				Если СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации >= 500
				Или ТекущаяУниверсальнаяДатаВМиллисекундах - СостояниеЧтенияРаздела.МоментПоследнейФиксации >= 20000 Тогда
					ЗафиксироватьПозициюЧтения(Message.Topic, Message.Partition, СостояниеЧтенияРаздела, Обработка)
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
		
		Для Каждого TopicPartition Из ConsumerAssignment Цикл
			
			СостояниеЧтенияРаздела = СостоянияЧтения[TopicPartition.Topic][TopicPartition.Partition];
			
			// Финальная фиксация текущей позиции чтения.
			ЗафиксироватьПозициюЧтения(TopicPartition.Topic, TopicPartition.Partition, СостояниеЧтенияРаздела, Обработка);
			
			ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
			УровеньЖурналаРегистрации.Информация, , TopicPartition.Topic+":"+Формат(TopicPartition.Partition, "ЧН=0; ЧГ=0"),
			"Завершено чтение раздела. Конечная позиция: "+Формат(СостояниеЧтенияРаздела.ТекущаяПозиция, "ЧН=0")+".");
			
			РегистрыСведений.КафкаПозиции.УдалитьСтарые(TopicPartition.Topic, TopicPartition.Partition);
			
		КонецЦикла;

		
	КонецЕсли;
	
	Для Каждого TopicPartition Из ConsumerAssignment Цикл
		СостояниеЧтенияРаздела = СостоянияЧтения[TopicPartition.Topic][TopicPartition.Partition];
		Обработка.ПослеЗагрузкиРаздела(СостояниеЧтенияРаздела.ТекущаяПозиция);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗафиксироватьПозициюЧтения(Тема, Раздел, СостояниеЧтенияРаздела, Обработка)
	
	Если СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ТранзакцияАктивна() Тогда
		ВызватьИсключение "Во время фиксации позиции чтения транзакция не должна быть активна.";
	КонецЕсли;
	
	// В случае буферизации сообщений обработкой нужно синхронизировать сброс буфера и фиксацию позиции чтения.
	Обработка.СброситьБуферы();
	
	РегистрыСведений.КафкаПозиции.УстановитьПозицию(Тема, Раздел, СостояниеЧтенияРаздела.ТекущаяПозиция);
	
	СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации = 0;
	СостояниеЧтенияРаздела.МоментПоследнейФиксации = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеФункции

Процедура УстановитьРеквизитыОбработки(Обработка, ПотенциальныеРеквизиты)
	
	ОбработкаМетаданные = Обработка.Метаданные();
	Для Каждого КЗ Из ПотенциальныеРеквизиты Цикл
		ОбработкаРеквизит = ОбработкаМетаданные.Реквизиты.Найти(КЗ.Ключ);
		Если ОбработкаРеквизит <> Неопределено Тогда
			Обработка[КЗ.Ключ] = КЗ.Значение;
			Если Обработка[КЗ.Ключ] <> КЗ.Значение Тогда
				ВызватьИсключение "Не удалось установить реквизит """+КЗ.Ключ+""" при иницилизации обработки выгрузки/загрузки данных.";
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция API(Кластер=Неопределено) Экспорт
	
	_Кластер = Кластер;
	Если Не ЗначениеЗаполнено(_Кластер) Тогда
		_Кластер = Справочники.КафкаКластеры.ПоУмолчанию;
	КонецЕсли;
	
	API = КафкаПереопределяемый.API();
	
	Если Не ЗначениеЗаполнено(_Кластер) Тогда
		API.Инициализировать();
	Иначе
		API.Инициализировать(_Кластер.ПроксиАдрес, _Кластер.ПроксиПользователь, _Кластер.ПроксиПароль, _Кластер.ПроксиТаймаут);
	КонецЕсли;
	
	Возврат API;
	
КонецФункции

Функция ШинаИнфо(ШинаСсылка) Экспорт
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ШиныОбмена.Ссылка КАК Ссылка,
	|	ШиныОбмена.ПометкаУдаления КАК ПометкаУдаления,
	|	ШиныОбмена.Родитель КАК Родитель,
	|	ШиныОбмена.ЭтоГруппа КАК ЭтоГруппа,
	|	ШиныОбмена.Наименование КАК Наименование,
	|	ШиныОбмена.Кластер КАК Кластер,
	|	ШиныОбмена.Вид КАК Вид,
	|	ШиныОбмена.Тема КАК Тема,
	|	ШиныОбмена.Узел КАК Узел,
	|	ШиныОбмена.ОбменПоРасписанию КАК ОбменПоРасписанию,
	|	ШиныОбмена.ОбменРасписание КАК ОбменРасписание,
	|	ШиныОбмена.Обработка КАК Обработка,
	|	ШиныОбмена.ОтправкаПараллелизм КАК ОтправкаПараллелизм,
	|	ШиныОбмена.ОтправкаБлокироватьТаблицуРегистрации КАК ОтправкаБлокироватьТаблицуРегистрации,
	|	ШиныОбмена.ПриемВРеальномВремени КАК ПриемВРеальномВремени,
	|	ШиныОбмена.ПриемДлительность КАК ПриемДлительность,
	|	ШиныОбмена.ПриемТаймаутОжидания КАК ПриемТаймаутОжидания,
	|	ШиныОбмена.ПриемТаймаутПолучателя КАК ПриемТаймаутПолучателя,
	|	ШиныОбмена.ПриемОднимРЗ КАК ПриемОднимРЗ,
	|	ЕСТЬNULL(ЕСТЬNULL(ШиныОбмена.ПользовательРЗ, ШиныОбмена.Родитель.ПользовательРЗ), """") КАК ПользовательРЗ
	|ИЗ
	|	Справочник.КафкаШиныОбмена КАК ШиныОбмена
	|ГДЕ
	|	ШиныОбмена.Ссылка = &Ссылка");
	Запрос.УстановитьПараметр("Ссылка", ШинаСсылка);
	РезультатЗапроса = Запрос.ВыполнитьПакет();
	
	Если РезультатЗапроса[0].Пустой() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Структура;
	
	Шапка = РезультатЗапроса[0].Выгрузить()[0];
	Для Каждого Колонка Из РезультатЗапроса[0].Колонки Цикл
		Результат.Вставить(Колонка.Имя, Шапка[Колонка.Имя]);
	КонецЦикла;
		
	Результат.ОбменРасписание = Результат.ОбменРасписание.Получить();
	//Если Результат.ОбменРасписание = Неопределено Тогда
	//	Результат.ОбменРасписание = Справочники.КафкаШиныОбмена.ОбменРасписаниеПоУмолчанию();
	//КонецЕсли;
	
	//Если Не ЗначениеЗаполнено(Результат.ОтправкаПараллелизм) Тогда
	//	Результат.ОтправкаПараллелизм = 4;
	//КонецЕсли;
	
	Если КафкаПовтИсп.ЭтоБэкап() Тогда
		Результат.Тема = "test-" + Результат.Тема;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ПараметрыПолучателя(ШинаСсылка)
	
	Результат = Новый Соответствие;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ПриемПараметры.Параметр КАК Параметр,
	|	ПриемПараметры.Значение КАК Значение
	|ИЗ
	|	Справочник.КафкаШиныОбмена.ПриемПараметры КАК ПриемПараметры
	|ГДЕ
	|	ПриемПараметры.Ссылка = &Ссылка
	|
	|УПОРЯДОЧИТЬ ПО
	|	ПриемПараметры.НомерСтроки");
	Запрос.УстановитьПараметр("Ссылка", ШинаСсылка);
	РезультатЗапроса = Запрос.Выполнить();
	
	ТЗ = РезультатЗапроса.Выгрузить();
	
	Для Каждого С Из ТЗ Цикл
		Результат.Вставить(С.Параметр, С.Значение);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура ОбновитьРегламентныеЗадания(ШинаСсылка, Удалить=Неопределено) Экспорт
		
	МетаданныеОтправка = Метаданные.РегламентныеЗадания.КафкаВыгрузка;
	МетаданныеПрием = Метаданные.РегламентныеЗадания.КафкаЗагрузка;
	
	ШинаИнфо = ШинаИнфо(ШинаСсылка);
	
	Если Удалить = Неопределено Тогда
		Удалить = ШинаИнфо.ПометкаУдаления;
	КонецЕсли;
		
	МассивЗаданийОтправка = Новый Массив;
	м = РегламентныеЗадания.ПолучитьРегламентныеЗадания(Новый Структура("Метаданные", МетаданныеОтправка));
	Для Каждого Задание Из м Цикл
		Если Задание.Параметры=Неопределено Или Задание.Параметры.Количество()=0 Или ТипЗнч(Задание.Параметры[0])<>Тип("СправочникСсылка.КафкаШиныОбмена") Или Не ЗначениеЗаполнено(Задание.Параметры[0]) Тогда
			УдалитьРегламентноеЗадание(Задание);
		ИначеЕсли Задание.Параметры[0] = ШинаСсылка Тогда
			МассивЗаданийОтправка.Добавить(Задание);
		КонецЕсли;
	КонецЦикла;
	
	МассивЗаданийПрием = Новый Массив;
	м = РегламентныеЗадания.ПолучитьРегламентныеЗадания(Новый Структура("Метаданные", МетаданныеПрием));
	Для Каждого Задание Из м Цикл
		Если Задание.Параметры=Неопределено Или Задание.Параметры.Количество()=0 Или ТипЗнч(Задание.Параметры[0])<>Тип("СправочникСсылка.КафкаШиныОбмена") Или Не ЗначениеЗаполнено(Задание.Параметры[0]) Тогда
			УдалитьРегламентноеЗадание(Задание);
		ИначеЕсли Задание.Параметры[0] = ШинаСсылка Тогда
			МассивЗаданийПрием.Добавить(Задание);
		КонецЕсли;
	КонецЦикла;
	
	Если Удалить Или Не ШинаИнфо.ОбменПоРасписанию Тогда
		Для Каждого Задание Из МассивЗаданийОтправка Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		Для Каждого Задание Из МассивЗаданийПрием Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		Возврат;
	КонецЕсли;
	
	Если ШинаИнфо.Вид = "Приемник" Тогда
		
		Для Каждого Задание Из МассивЗаданийПрием Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		
		Задание = Неопределено;
		Если МассивЗаданийОтправка.Количество() > 0 Тогда
			Задание = МассивЗаданийОтправка.Получить(0);
			МассивЗаданийОтправка.Удалить(0);
		КонецЕсли;
			
		ОбновитьРегламентноеЗадание(Задание, МетаданныеОтправка, ШинаИнфо);
					
		Для Каждого Задание Из МассивЗаданийОтправка Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		
	ИначеЕсли ШинаИнфо.Вид = "Источник" Тогда
		
		Для Каждого Задание Из МассивЗаданийОтправка Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		
		Если ШинаИнфо.ПриемОднимРЗ Тогда
			
			Задание = Неопределено;
			//Если МассивЗаданийПрием.Количество() > 0 Тогда
			//	Задание = МассивЗаданийПрием.Получить(0);
			//	МассивЗаданийПрием.Удалить(0);
			//КонецЕсли;
			
			ОбновитьРегламентноеЗадание(Задание, МетаданныеПрием, ШинаИнфо);
			
		Иначе
			
			Кафка = API(ШинаИнфо.Кластер);
						
			TopicMetadata = Кафка.GetTopicMetadata(ШинаИнфо.Тема);
			Если TopicMetadata = Неопределено Тогда
				ВызватьИсключение Кафка.ОписаниеОшибки;
			КонецЕсли;
						
			Для Каждого PartitionMetadata Из TopicMetadata.Partitions Цикл
				
				ПодходящееЗадание = Неопределено;
				Для индекс = 0 По МассивЗаданийПрием.ВГраница() Цикл
					Задание = МассивЗаданийПрием[индекс];
					Если Задание.Параметры.Количество()>=2 И Задание.Параметры[1]=PartitionMetadata.Partition Тогда
						ПодходящееЗадание = Задание;
						МассивЗаданийПрием.Удалить(индекс);
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				ОбновитьРегламентноеЗадание(ПодходящееЗадание, МетаданныеПрием, ШинаИнфо, PartitionMetadata.Partition);
				
			КонецЦикла;
			
		КонецЕсли;
						
		Для Каждого Задание Из МассивЗаданийПрием Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		
	Иначе
		ВызватьИсключение "Неизвестный вид шины: " + ШинаИнфо.Вид;
	КонецЕсли;
	
КонецПроцедуры
Функция ОбновитьРегламентноеЗадание(Задание, ЗаданиеМетаданные, ШинаИнфо, Раздел=Неопределено)
	
	Если Задание = Неопределено Тогда
		Задание = РегламентныеЗадания.СоздатьРегламентноеЗадание(ЗаданиеМетаданные);
	КонецЕсли;
	
	Параметры = Новый Массив;
	Параметры.Добавить(ШинаИнфо.Ссылка);
	Если ЗаданиеМетаданные = Метаданные.РегламентныеЗадания.КафкаЗагрузка Тогда
		Если Раздел = Неопределено Тогда
			Параметры.Добавить(Неопределено);
		Иначе
			Параметры.Добавить(Раздел);
			РазделСтрока = Формат(Раздел, "ЧН=0; ЧГ=0");
		КонецЕсли;
	КонецЕсли;
	
	Задание.Параметры = Параметры;
	Задание.Наименование = ЗаданиеМетаданные.Синоним+": "+ШинаИнфо.Наименование+?(Раздел=Неопределено, "", " ("+РазделСтрока+")");
	Задание.Ключ = Строка(ШинаИнфо.Ссылка.УникальныйИдентификатор()) + ?(Раздел=Неопределено, "", "_"+РазделСтрока);
	Задание.Расписание = ШинаИнфо.ОбменРасписание;
	Задание.Использование = Не ШинаИнфо.ПометкаУдаления;
	Задание.ИмяПользователя = ШинаИнфо.ПользовательРЗ;
	Задание.Записать();
	
КонецФункции
Процедура УдалитьРегламентноеЗадание(РегламентноеЗадание)
	
	РегламентноеЗадание.Удалить();
	
	Отбор = Новый Структура;
	Отбор.Вставить("РегламентноеЗадание", РегламентноеЗадание);
	Отбор.Вставить("Состояние", СостояниеФоновогоЗадания.Активно);
	
	АктивныеФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(Отбор);
		
	Для Каждого ФоновоеЗадание Из АктивныеФоновыеЗадания Цикл
		ФоновоеЗадание.Отменить();
	КонецЦикла;
	
КонецПроцедуры

Функция Тема(ИсходнаяТема) Экспорт
		
	Если КафкаПовтИсп.ЭтоБэкап() Тогда
		Возврат "test-" + ИсходнаяТема;
	КонецЕсли;
	
	Возврат ИсходнаяТема;
	
КонецФункции

Процедура ПолучитьСмещенияТемыВФоне(Кластер, Тема, АдресРезультата=Неопределено) Экспорт
	
	Кафка = API(Кластер);
	
	Результат = Кафка.ПолучитьСмещенияТемы(Тема);
	
	Если Результат <> Неопределено Тогда
		ОписаниеРезультата = Новый Структура("Успех, Результат", Истина, Результат);
	Иначе
		ОписаниеРезультата = Новый Структура("Успех, ОписаниеОшибки", Ложь, Кафка.ОписаниеОшибки);
	КонецЕсли;
	
	ПоместитьВоВременноеХранилище(ОписаниеРезультата, АдресРезультата);
	
КонецПроцедуры

#КонецОбласти
