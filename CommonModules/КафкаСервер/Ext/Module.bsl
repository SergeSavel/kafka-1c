// Copyright 2023 Савельев Сергей Владимирович
//
// Лицензировано согласно Лицензии Apache, Версия 2.0 ("Лицензия");
// вы можете использовать этот файл только в соответствии с Лицензией.
// Вы можете найти копию Лицензии по адресу
//
// http://www.apache.org/licenses/LICENSE-2.0.
//
// За исключением случаев, когда это регламентировано существующим
// законодательством, или если это не оговорено в письменном соглашении,
// программное обеспечение, распространяемое на условиях данной Лицензии,
// предоставляется "КАК ЕСТЬ", и любые явные или неявные ГАРАНТИИ ОТВЕРГАЮТСЯ.
// Информацию об основных правах и ограничениях, применяемых к определенному
// языку согласно Лицензии, вы можете найти в данной Лицензии.

#Область Выгрузка

Процедура ВыгрузитьРегламент(Шина) Экспорт
	
	Если КафкаПовтИсп.ЭтоБэкап() И Не КафкаПереопределяемый.РазрешенОбменБэкапов() Тогда
		ТекстСообщения = "Обмен бэкапов запрещен. Выгрузка не будет запущена.";
		КафкаКлиентСервер.СообщитьПользователю(ТекстСообщения);
		ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+Шина.Наименование, УровеньЖурналаРегистрации.Предупреждение, , , ТекстСообщения);
		Возврат;
	КонецЕсли;
		
	Выгрузить(Шина);
	
КонецПроцедуры

Процедура Выгрузить(Шина) Экспорт
	
	Если Не ЗначениеЗаполнено(Шина) Тогда
		ВызватьИсключение "Не заполнена шина. Выгрузка невозможна.";
	КонецЕсли;
	
	ШинаИнфо = ШинаИнфо(Шина);
		
	Если Не ЗначениеЗаполнено(ШинаИнфо.Узел) Тогда
		ВызватьИсключение "Не заполнен узел шины. Выгрузка невозможна.";
	КонецЕсли;
	
	Параллелизм = ИнициализироватьПараллелизм(ШинаИнфо.ОбменКоличествоПотоков);
	
	Обработка = КафкаПереопределяемый.ПолучитьОбработку(ШинаИнфо);
	
	// Установим реквизиты обработки.
	ПотенциальныеРеквизитыОбработки = Новый Структура;
	ПотенциальныеРеквизитыОбработки.Вставить("Шина", ШинаИнфо.Ссылка);
	ПотенциальныеРеквизитыОбработки.Вставить("Узел", ШинаИнфо.Узел);
	УстановитьРеквизитыОбработки(Обработка, ПотенциальныеРеквизитыОбработки);
	
	Заголовки = Новый Соответствие;
	
	// Инициализируем API Кафки.
	Кафка = КафкаКлиентСервер.Адаптер(ШинаИнфо.Кластер);
	
	ВыгружаемыеТаблицы = Обработка.ВыгружаемыеТаблицы();
	
	ИнформацияОбОшибке = Неопределено;
	
	Если Обработка.ПередВыгрузкойШины(ШинаИнфо, Заголовки, Кафка) Тогда
		
		Попытка
			ВыгрузитьУзел(ШинаИнфо, Обработка, Кафка, Заголовки, ВыгружаемыеТаблицы, Параллелизм);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
		
		Обработка.ПослеВыгрузкиШины(ШинаИнфо, ИнформацияОбОшибке);
		
	КонецЕсли;
		
	Если ИнформацияОбОшибке <> Неопределено Тогда
		ТекстОшибки = "Выгрузка данных в шину """+ШинаИнфо.Наименование+""" завершилась ошибкой.
		|" + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
		
КонецПроцедуры

Процедура ВыгрузитьУзел(ШинаИнфо, Обработка, Кафка, ОбщиеЗаголовки, ВыгружаемыеТаблицы, Параллелизм)
	
	//// Установим реквизиты обработки.
	//ПотенциальныеРеквизитыОбработки = Новый Структура;
	//ПотенциальныеРеквизитыОбработки.Вставить("Узел", ШинаИнфо.Узел);
	//УстановитьРеквизитыОбработки(Обработка, ПотенциальныеРеквизитыОбработки);
	
	Заголовки = Новый Соответствие;
	Для Каждого КЗ Из ОбщиеЗаголовки Цикл
		Заголовки.Вставить(КЗ.Ключ, КЗ.Значение);
	КонецЦикла;
	
	//Если Не Обработка.ПередВыгрузкойУзла(Заголовки) Тогда
	//	Возврат;
	//КонецЕсли;
	
	Изменения = ПолучитьИзменения(ШинаИнфо.Узел, ШинаИнфо.ОтправкаБлокироватьТаблицуРегистрации);
	
	Если Изменения.Количество() > 0 Тогда
		
		Конфигурация = КонфигурацияШины(ШинаИнфо.Ссылка);
		Если Параллелизм.МаксСтепень < 2 Тогда
			Конфигурация.Вставить("linger.ms", "0");
		КонецЕсли;
		
		// Создадим экземпляр отправителя внутри прокси.
		Producer = Кафка.ProducerCreate(
			ШинаИнфо.Наименование,
			Конфигурация,
			KeyValueType(ШинаИнфо.КлючСердес),
			KeyValueType(ШинаИнфо.ЗначениеСердес),
			ШинаИнфо.КлиентТаймаут
		);
		
		Если Producer = Неопределено Тогда
			ВызватьИсключение Кафка.ОписаниеОшибки;
		КонецЕсли;
		
		Попытка
						
			ПредПорядок = Неопределено;
			
			Для Каждого ВыгружаемаяТаблица Из ВыгружаемыеТаблицы Цикл
						
				РезультатЗапросаИзменения = Изменения.Получить(ВыгружаемаяТаблица.ПолноеИмя);
				
				Если РезультатЗапросаИзменения = Неопределено Или РезультатЗапросаИзменения.Пустой() Тогда
					Продолжить; // нечего выгружать по текущей таблице
				КонецЕсли;
				
				// Перед началом выгрузки данных нового порядка дожидаемся завершения выгрузки данных старого порядка.
				Если ПредПорядок <> ВыгружаемаяТаблица.Порядок Тогда
					ДождатьсяОсвобожденияПулаПотоков(Параллелизм, Истина);
				КонецЕсли;
				
				ПредПорядок = ВыгружаемаяТаблица.Порядок;
							
				ВыгрузитьТаблицу(ШинаИнфо, Обработка, Кафка, Producer, ВыгружаемаяТаблица, РезультатЗапросаИзменения, Заголовки, Параллелизм);
						
			КонецЦикла;
				
			ДождатьсяОсвобожденияПулаПотоков(Параллелизм, Истина);
			
			Кафка.ProducerRelease(Producer.Id, Producer.Token);
			
		Исключение
			
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			
			Кафка.ProducerRelease(Producer.Id, Producer.Token);
			
			ВызватьИсключение;
			
		КонецПопытки;
		
	КонецЕсли;
	
	//Обработка.ПослеВыгрузкиУзла();
	
КонецПроцедуры

Функция ПолучитьИзменения(Узел, Блокировать=Ложь)
		
	МассивТекстЗапроса = Новый Массив;
	МассивИменаТаблиц  = Новый Массив;
	
	СоставТаблиц = Узел.Метаданные().Состав;
	
	Если Блокировать Тогда
		Блокировка = Новый БлокировкаДанных;
	КонецЕсли;
	
	Для Каждого ЭлементСостава Из СоставТаблиц Цикл
		ТаблицаИнфо = КафкаПовтИсп.ОписаниеТаблицы(ЭлементСостава.Метаданные.ПолноеИмя());
		
		Если ТаблицаИнфо.ЭтоКонстанта Тогда
			МассивТекстЗапроса.Добавить(
			"ВЫБРАТЬ ПЕРВЫЕ 999999999
			|	ИСТИНА
			|ИЗ
			|	" + ТаблицаИнфо.ПолноеИмя + ".Изменения
			|ГДЕ
			|	Узел = &Узел"); 
		ИначеЕсли ТаблицаИнфо.ЭтоСсылочныйОбъект Тогда
			МассивТекстЗапроса.Добавить(
			"ВЫБРАТЬ ПЕРВЫЕ 999999999
			|	Изменения.Ссылка,
			|	ВЫБОР
			|		КОГДА ОсновнаяТаблица.Ссылка ЕСТЬ NULL 
			|			ТОГДА ИСТИНА
			|		ИНАЧЕ ЛОЖЬ
			|	КОНЕЦ КАК ЭтоУдаление
			|ИЗ
			|	" + ТаблицаИнфо.ПолноеИмя + ".Изменения КАК Изменения
			|		ЛЕВОЕ СОЕДИНЕНИЕ " + ТаблицаИнфо.ПолноеИмя + " КАК ОсновнаяТаблица
			|		ПО Изменения.Ссылка = ОсновнаяТаблица.Ссылка
			|ГДЕ
			|	Изменения.Узел = &Узел"); 
		Иначе
			СтрокаИзмерения = ?(ТаблицаИнфо.КлючевыеПоля.Количество()=0, "ИСТИНА", СтрСоединить(ТаблицаИнфо.КлючевыеПоля, ","));
			МассивТекстЗапроса.Добавить(
			"ВЫБРАТЬ ПЕРВЫЕ 999999999
			|	" + СтрокаИзмерения + "
			|ИЗ
			|	" + ТаблицаИнфо.ПолноеИмя + ".Изменения
			|ГДЕ
			|	Узел = &Узел");
		КонецЕсли;
		
		МассивИменаТаблиц.Добавить(ТаблицаИнфо.ПолноеИмя);
		
		Если Блокировать Тогда
			ЭлементБлокировки = Блокировка.Добавить(ТаблицаИнфо.ПолноеИмя+?(ТаблицаИнфо.ЭтоПодчиненныйРегистр Или ТаблицаИнфо.ЭтоПоследовательность, ".НаборЗаписей", ""));
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		КонецЕсли;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = СтрСоединить(МассивТекстЗапроса, Символы.ПС+";"+Символы.ПС);
	Запрос.УстановитьПараметр("Узел", Узел);
	
	Если Блокировать Тогда
		
		КоличествоПопыток = 10;
		Пока Истина Цикл
			КоличествоПопыток = КоличествоПопыток - 1;
			
			НачатьТранзакцию();
			
			Попытка
				
				Блокировка.Заблокировать();
				
				МассивРезультаты = Запрос.ВыполнитьПакет();
				
				ЗафиксироватьТранзакцию();
				
				Прервать;
			Исключение
				ИнформацияОбОшибке = ИнформацияОбОшибке();
							
				ОтменитьТранзакцию();
				
				Если КоличествоПопыток > 0 Тогда
					ОписаниеОшибки = КафкаКлиентСервер.КорневаяИнформацияОбОшибке(ИнформацияОбОшибке).Описание;
					ОписаниеОшибкиНРег = НРег(ОписаниеОшибки);
					Если Найти(ОписаниеОшибкиНРег, "блокиров")>0 Или Найти(ОписаниеОшибкиНРег, "lock")>0 Тогда
						Продолжить;
					КонецЕсли;
				КонецЕсли;
					
				ВызватьИсключение;
			КонецПопытки
		КонецЦикла;
		
	Иначе
		
		МассивРезультаты = Запрос.ВыполнитьПакет();
		
	КонецЕсли;
		
	Результат = Новый Соответствие;
	Для индекс = 0 По МассивИменаТаблиц.ВГраница() Цикл
		ИмяТаблицы = МассивИменаТаблиц[индекс];
		РезультатЗапроса = МассивРезультаты[индекс];
		Результат.Вставить(ИмяТаблицы, РезультатЗапроса);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура ВыгрузитьТаблицу(ШинаИнфо, Обработка, Кафка, Producer, Таблица, РезультатЗапросаИзменения, ОбщиеЗаголовки, Параллелизм)
	
	Если ЗначениеЗаполнено(Таблица.РазмерПакета) Тогда
		РазмерПакета = Таблица.РазмерПакета;
	Иначе
		РазмерПакета = 250;
	КонецЕсли;
	
	Заголовки = Новый Соответствие;
	Для Каждого КЗ Из ОбщиеЗаголовки Цикл
		Заголовки.Вставить(КЗ.Ключ, КЗ.Значение);
	КонецЦикла;
	
	ТаблицаИнфо = КафкаПовтИсп.ОписаниеТаблицы(Таблица.ПолноеИмя);
	
	Если Не Обработка.ПередВыгрузкойТаблицы(ТаблицаИнфо, Заголовки) Тогда
		Возврат;
	КонецЕсли;
	
	КлючИмя = Неопределено;
	КлючПространствоИмен = Неопределено;
	
	Если ШинаИнфо.КлючСердес = Перечисления.КафкаСердес.СтрокаAvro
	Или ШинаИнфо.КлючСердес = Перечисления.КафкаСердес.СтруктураAvro Тогда
		СхемаКлюча = Обработка.СхемаКлюча(ТаблицаИнфо, ШинаИнфо.КлючСердес);
		Если СхемаКлюча = Неопределено Тогда
			ВызватьИсключение "Отсутствует схема ключа для объекта """+ТаблицаИнфо.ПолноеИмя+""".";
		КонецЕсли;
		Успех = Кафка.ProducerSetSchema(
			Producer.Id,
			Producer.Token,
			СхемаКлюча
		);
		Если Успех <> Истина Тогда
			ВызватьИсключение
			"Не удалось отправить схему ключа для объекта """+ТаблицаИнфо.ПолноеИмя+""".
			|"+Кафка.ОписаниеОшибки;
		КонецЕсли;
		КафкаКлиентСервер.AvroСхемаПолучитьИмяПространствоИмен(СхемаКлюча, КлючИмя, КлючПространствоИмен);
	КонецЕсли;
	
	ЗначениеИмя = Неопределено;
	ЗначениеПространствоИмен = Неопределено;
	
	Если ШинаИнфо.ЗначениеСердес = Перечисления.КафкаСердес.СтрокаAvro
	Или ШинаИнфо.ЗначениеСердес = Перечисления.КафкаСердес.СтруктураAvro Тогда
		СхемаЗначения = Обработка.СхемаЗначения(ТаблицаИнфо, ШинаИнфо.ЗначениеСердес);
		Если СхемаЗначения = Неопределено Тогда
			ВызватьИсключение "Отсутствует схема значения для объекта """+ТаблицаИнфо.ПолноеИмя+""".";
		КонецЕсли;
		Успех = Кафка.ProducerSetSchema(
			Producer.Id,
			Producer.Token,
			СхемаЗначения
		);
		Если Успех <> Истина Тогда
			ВызватьИсключение
			"Не удалось отправить схему значения для объекта """+ТаблицаИнфо.ПолноеИмя+""".
			|"+Кафка.ОписаниеОшибки;
		КонецЕсли;
		КафкаКлиентСервер.AvroСхемаПолучитьИмяПространствоИмен(СхемаЗначения, ЗначениеИмя, ЗначениеПространствоИмен);
	КонецЕсли;
	
	ИзмененияВыборка = РезультатЗапросаИзменения.Выбрать();
	
	ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
			УровеньЖурналаРегистрации.Примечание, ШинаИнфо.Узел.Метаданные(), ШинаИнфо.Узел,
			"Начата асинхронная отправка "+ИзмененияВыборка.Количество()+" объектов таблицы '"+Таблица.ПолноеИмя+"'.");
			
	ТекущийПакет = Неопределено;
						
	// Обходим все измененные/удаленные объекты.
	Пока ИзмененияВыборка.Следующий() Цикл
		
		Если ТекущийПакет = Неопределено Тогда
			
			Данные = Новый ТаблицаЗначений;
			Для Каждого Колонка Из РезультатЗапросаИзменения.Колонки Цикл
				Данные.Колонки.Добавить(Колонка.Имя);
			КонецЦикла;
			
			ТекущийПакет = Новый Структура("ТаблицаИнфо, Заголовки, Данные, Размер", ТаблицаИнфо, Заголовки, Данные, 0);
			
			//Если КлючИмя <> Неопределено Тогда
				ТекущийПакет.Вставить("КлючИмя", КлючИмя);
			//КонецЕсли;
			//Если КлючПространствоИмен <> Неопределено Тогда
				ТекущийПакет.Вставить("КлючПространствоИмен", КлючПространствоИмен);
			//КонецЕсли;
			
			//Если ЗначениеИмя <> Неопределено Тогда
				ТекущийПакет.Вставить("ЗначениеИмя", ЗначениеИмя);
			//КонецЕсли;
			//Если ЗначениеПространствоИмен <> Неопределено Тогда
				ТекущийПакет.Вставить("ЗначениеПространствоИмен", ЗначениеПространствоИмен);
			//КонецЕсли;
						
		КонецЕсли;					
				
		ЗаполнитьЗначенияСвойств(ТекущийПакет.Данные.Добавить(), ИзмененияВыборка);
		ТекущийПакет.Размер = ТекущийПакет.Размер + 1;
		
		Если ТекущийПакет.Размер >= Таблица.РазмерПакета Тогда
			ВыгрузитьПакет(ШинаИнфо, Обработка, Producer, Параллелизм, ТекущийПакет);
			ТекущийПакет = Неопределено;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ТекущийПакет <> Неопределено Тогда
		ВыгрузитьПакет(ШинаИнфо, Обработка, Producer, Параллелизм, ТекущийПакет);
		ТекущийПакет = Неопределено;
	КонецЕсли;
		
	ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
			УровеньЖурналаРегистрации.Примечание, ШинаИнфо.Узел.Метаданные(), ШинаИнфо.Узел,
			"Завершена асинхронная отправка "+ИзмененияВыборка.Количество()+" объектов таблицы '"+Таблица.ПолноеИмя+"'.");
			
	Обработка.ПослеВыгрузкиТаблицы(ТаблицаИнфо);
	
КонецПроцедуры

Процедура ВыгрузитьПакет(ШинаИнфо, Обработка, Producer, Параллелизм, Пакет)
	
	ДождатьсяОсвобожденияПулаПотоков(Параллелизм);	
		
	Если Параллелизм.МаксСтепень < 2 Тогда
		// Выгрузим пакет в этом же сеансе.
		
		ВыгрузитьПакетЭтотСеанс(ШинаИнфо, Обработка, Producer.Id, Producer.Token, Пакет);
		
		Параллелизм.ОбъектыСчетчик = Параллелизм.ОбъектыСчетчик + Пакет.Размер;
		
    Иначе
		// Выгрузим пакет в отдельном фоновом сеансе.
		
		Параллелизм.ПотокиСчетчик = Параллелизм.ПотокиСчетчик + 1;
		
		ПараметрыФЗ = Новый Массив;
		ПараметрыФЗ.Добавить(ШинаИнфо);
		ПараметрыФЗ.Добавить(Producer.Id);
		ПараметрыФЗ.Добавить(Producer.Token);
		ПараметрыФЗ.Добавить(Пакет);
		
		ФЗ = ФоновыеЗадания.Выполнить("КафкаСервер.ВыгрузитьПакетОтдельныйСеанс", ПараметрыФЗ, ,
				"Поток выгрузки данных в шину '"+ШинаИнфо.Наименование+"' № "+Параллелизм.ПотокиСчетчик);
				
		Параллелизм.Потоки.Добавить(ФЗ);
		Параллелизм.ПотокиРазмеры.Вставить(ФЗ.УникальныйИдентификатор, Пакет.Размер);
		
	КонецЕсли;
		
КонецПроцедуры

Процедура ВыгрузитьПакетОтдельныйСеанс(ШинаИнфо, ProducerId, ProducerToken, Пакет) Экспорт
	
	Обработка = КафкаПереопределяемый.ПолучитьОбработку(ШинаИнфо);
	
	// Установим реквизиты обработки.
	ПотенциальныеРеквизитыОбработки = Новый Структура;
	ПотенциальныеРеквизитыОбработки.Вставить("Узел", ШинаИнфо.Узел);
	ПотенциальныеРеквизитыОбработки.Вставить("Шина", ШинаИнфо.Ссылка);
	УстановитьРеквизитыОбработки(Обработка, ПотенциальныеРеквизитыОбработки);
	
	ВыгрузитьПакетЭтотСеанс(ШинаИнфо, Обработка, ProducerId, ProducerToken, Пакет);
	
КонецПроцедуры

Процедура ВыгрузитьПакетЭтотСеанс(ШинаИнфо, Обработка, ProducerId, ProducerToken, Пакет)
	
	// Инициализируем соединение с Кафкой.
	Кафка = КафкаКлиентСервер.Адаптер(ШинаИнфо.Кластер);
	
	ТаблицаИнфо = Пакет.ТаблицаИнфо;
	
	Обработка.ПередВыгрузкойПакета(ТаблицаИнфо, Кафка);
			
	Для Каждого СтрокаПакета Из Пакет.Данные Цикл
		
		// Скопируем общие заголовки.
		Заголовки = Новый Соответствие;
		Для Каждого КЗ Из Пакет.Заголовки Цикл
			Заголовки.Вставить(КЗ.Ключ, КЗ.Значение);
		КонецЦикла;
		
		// Итерацию выгрузки каждого объекта выполняем в отдельной транзакции.
		// Внутри транзакции только необходимый минимум действий.
		НачатьТранзакцию();
		
		Попытка
		
			// Устанавливаем разделяемую блокировку 
			ПространствоБлокировки = ТаблицаИнфо.ПолноеИмя;
			Если ТаблицаИнфо.ЭтоПодчиненныйРегистр Или ТаблицаИнфо.ЭтоПоследовательность Тогда
				ПространствоБлокировки = ПространствоБлокировки + ".НаборЗаписей";
			КонецЕсли;
			Блокировка = Новый БлокировкаДанных;
			ЭлементБлокировки = Блокировка.Добавить(ПространствоБлокировки);
			Для Каждого Поле Из ТаблицаИнфо.КлючевыеПоля Цикл
				ЭлементБлокировки.УстановитьЗначение(Поле, СтрокаПакета[Поле]);
			КонецЦикла;
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
			Блокировка.Заблокировать();
			
			// Читаем объект.
			Если ТаблицаИнфо.ЭтоКонстанта Тогда
				
				Объект = Константы[ТаблицаИнфо.Имя].СоздатьМенеджерЗначения();
				Объект.Прочитать();
			
			ИначеЕсли ТаблицаИнфо.ЭтоСсылочныйОбъект Тогда
				
				Если СтрокаПакета.ЭтоУдаление Тогда
					Объект = Новый УдалениеОбъекта(СтрокаПакета.Ссылка);
				Иначе // Это обычное изменение
					Объект = СтрокаПакета.Ссылка.ПолучитьОбъект();
				КонецЕсли;
					
			Иначе // Это регистр или последовательность
			
				РегистрМенеджер = КафкаПовтИсп.МенеджерТаблицы(ТаблицаИнфо.ПолноеИмя);
				
				Объект = РегистрМенеджер.СоздатьНаборЗаписей();
				Для Каждого Поле Из ТаблицаИнфо.КлючевыеПоля Цикл
					Объект.Отбор[Поле].Установить(СтрокаПакета[Поле]);
				КонецЦикла;
				Объект.Прочитать();
				
			КонецЕсли;
						
			// Разрегистрируем объект.
			ПланыОбмена.УдалитьРегистрациюИзменений(ШинаИнфо.Узел, Объект);
			
			ВыгружатьОбъект = Обработка.ПередВыгрузкойОбъекта(Объект, ТаблицаИнфо, Заголовки);
			Если ВыгружатьОбъект Тогда
				
				// Ключ сообщения нужен для правильного распределения сообщений по разделам (партициям).
				// Сообщения с одинаковым ключом будут прочитаны в том же порядке, в котором были отправлены.
				Ключ = Обработка.СообщениеКлюч(Объект, ТаблицаИнфо, Заголовки);
				Ключ = СериализоватьВСтроку(Ключ, ШинаИнфо.КлючСердес, Пакет.КлючИмя, Пакет.КлючПространствоИмен);
				
				// Сериализуем объект
				Значение = Обработка.СообщениеЗначение(Объект, ТаблицаИнфо, Заголовки);
				Значение = СериализоватьВСтроку(Значение, ШинаИнфо.ЗначениеСердес, Пакет.ЗначениеИмя, Пакет.ЗначениеПространствоИмен);
								
				Если ШинаИнфо.ТемаЭтоПрефикс Тогда
					ТемаСуффикс = Обработка.СообщениеСуффиксТемы(Объект, ТаблицаИнфо, Заголовки);
					Если Не ЗначениеЗаполнено(ТемаСуффикс) Тогда
						ВызватьИсключение "Не заполнен суффикс темы.";
					КонецЕсли;
					Тема = ШинаИнфо.ТемаПрефикс + ТемаСуффикс;
				Иначе
					Тема = ШинаИнфо.Тема;
				КонецЕсли;
				
				// Отправляем данные. Это должно быть самое последнее действие в транзакции.
				DeliveryResult = Кафка.ProducerProduce(ProducerId, ProducerToken, Тема, , Ключ, Значение, Заголовки);
				Если DeliveryResult = Неопределено Тогда
					ВызватьИсключение Кафка.ОписаниеОшибки;
				ИначеЕсли DeliveryResult.Status <> "Persisted" Тогда
					ВызватьИсключение "Не удалось отправить сообщение. Статус доставки: '"+DeliveryResult.Status+"'."; // TODO: Более подробная причина.
				КонецЕсли;
									
			КонецЕсли;
						
			ЗафиксироватьТранзакцию();
			
		Исключение
			
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			
			ОтменитьТранзакцию();
			
			ВызватьИсключение
			"Не удалось выполнить отправку объекта "+ПредставлениеОбъекта(Объект, ТаблицаИнфо)+".
			|"+ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
			
		КонецПопытки;
		
		Если ВыгружатьОбъект Тогда
			Обработка.ПослеВыгрузкиОбъекта(Объект, ТаблицаИнфо, DeliveryResult);
		КонецЕсли;
		
	КонецЦикла;
	
	Обработка.ПослеВыгрузкиПакета(ТаблицаИнфо);
	
КонецПроцедуры

Функция СериализоватьВСтроку(Значение, Сердес, СхемаИмя, СхемаПространствоИмен)
	
	Если Сердес = Перечисления.КафкаСердес.Null Тогда
		
		Если Значение <> Неопределено Тогда
			ВызватьИсключение "Некорректный тип исходных данных для сериализации.";
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.ДвоичныеДанные Тогда
		
		Если Значение = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ЗначениеТип = ТипЗнч(Значение);
		Если ЗначениеТип = Тип("ДвоичныеДанные") Тогда
			Возврат ПолучитьBase64СтрокуИзДвоичныхДанных(Значение);
		ИначеЕсли ЗначениеТип = Тип("БуферДвоичныхДанных") Тогда
			Возврат ПолучитьBase64СтрокуИзБуфераДвоичныхДанных(Значение);
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Uuid Тогда
		
		Если Значение = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Если ТипЗнч(Значение) = Тип("УникальныйИдентификатор") Тогда
			Возврат Строка(Значение);
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Строка Тогда
		
		Если Значение = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Если ТипЗнч(Значение) = Тип("Строка") Тогда
			Возврат Значение;
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СтрокаAvro Тогда
		
		Если Значение = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ЗначениеТип = ТипЗнч(Значение);
		Если ЗначениеТип = Тип("Строка") Тогда
			Возврат Значение;
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СтруктураAvro Тогда
		
		Если Значение = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ЗначениеТип = ТипЗнч(Значение);
		Если ЗначениеТип = Тип("Структура") Или ЗначениеТип = Тип("ФиксированнаяСтруктура") Тогда
						
			Возврат КафкаКлиентСервер.AvroСериализовать(Значение, СхемаИмя, СхемаПространствоИмен);
			
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СтруктураJson Тогда
		
		Если Значение = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ЗначениеТип = ТипЗнч(Значение);
		Если ЗначениеТип = Тип("Структура") Или ЗначениеТип = Тип("ФиксированнаяСтруктура") Тогда
			Возврат КафкаКлиентСервер.JsonСериализовать(Значение, Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СоответствиеJson Тогда
		
		Если Значение = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ЗначениеТип = ТипЗнч(Значение);
		Если ЗначениеТип = Тип("Соответствие") Или ЗначениеТип = Тип("ФиксированноеСоответствие") Тогда
			Возврат КафкаКлиентСервер.JsonСериализовать(Значение, Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
		Иначе
			ВызватьИсключение "Некорректный тип исходных данных для сериализации.";
		КонецЕсли;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Xml Тогда
		
		Если Значение = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Возврат КафкаКлиентСервер.XmlСериализовать(Значение, Ложь);
				
	Иначе
		ВызватьИсключение "Неожиданнный/неподдерживаемый тип сериализации: """+Сердес+"""."
	КонецЕсли;
	
КонецФункции

#Область ВыгрузкаВспомогательныеФункции

Функция ИнициализироватьПараллелизм(МаксСтепень)
		
	Результат = Новый Структура;
	
	Результат.Вставить("МаксСтепень", МаксСтепень);
	Результат.Вставить("Потоки", Новый Массив);
	Результат.Вставить("ПотокиСчетчик", 0);
	Результат.Вставить("ПотокиРазмеры", Новый Соответствие);
	Результат.Вставить("ОбъектыСчетчик", 0);
	
	Если Результат.МаксСтепень < 1 Тогда
		Результат.МаксСтепень = 1;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Процедура ДождатьсяОсвобожденияПулаПотоков(Параллелизм, ПолноеОсвобождение=Ложь)
	
	Если Не ПолноеОсвобождение И Параллелизм.Потоки.Количество()<Параллелизм.МаксСтепень Тогда
		Возврат;
	КонецЕсли;
	
	ЦелевоеКоличествоПотоков = ?(ПолноеОсвобождение, 0,	Параллелизм.МаксСтепень-1);
	
	Пока Параллелизм.Потоки.Количество() > ЦелевоеКоличествоПотоков Цикл
	
		Параллелизм.Потоки = ФоновыеЗадания.ОжидатьЗавершенияВыполнения(Параллелизм.Потоки, 5);
			
		Колво = Параллелизм.Потоки.Количество();
		Индекс = Колво;
		Пока Индекс > 0 Цикл
			
			Индекс = Индекс - 1;
			ФЗ = Параллелизм.Потоки[Индекс];
			
			Если ФЗ.Состояние = СостояниеФоновогоЗадания.Завершено Тогда
				
				Параллелизм.Потоки.Удалить(Индекс);
				
				Параллелизм.ОбъектыСчетчик = Параллелизм.ОбъектыСчетчик + Параллелизм.ПотокиРазмеры[ФЗ.УникальныйИдентификатор];
				Параллелизм.ПотокиРазмеры.Удалить(ФЗ.УникальныйИдентификатор);
				
			ИначеЕсли ФЗ.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда
				
				ОписаниеОшибки = "Один из потоков завершился ошибкой.";
				Если ФЗ.ИнформацияОбОшибке <> Неопределено Тогда
					ОписаниеОшибки = ОписаниеОшибки + Символы.ПС + ПодробноеПредставлениеОшибки(ФЗ.ИнформацияОбОшибке);
				КонецЕсли;
				
				ВызватьИсключение ОписаниеОшибки;
				
			ИначеЕсли ФЗ.Состояние = СостояниеФоновогоЗадания.Отменено Тогда
				
				ВызватьИсключение "Один из потоков был вручную отменен.";
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ПредставлениеОбъекта(Объект, ТаблицаИнфо)
	
	Результат = ТаблицаИнфо.ПолноеИмя;
	
	Если Объект <> Неопределено Тогда
		Если ТаблицаИнфо.ЭтоСсылочныйОбъект Тогда
			Результат = Результат+" ("""+Строка(Объект)+""")"
		ИначеЕсли ТаблицаИнфо.ЭтоПодчиненныйРегистр Тогда
			Результат = Результат+" ("+Строка(Объект.Отбор.Регистратор.Значение)+")"
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область Загрузка

Процедура ЗагрузитьРегламент(Шина) Экспорт
	
	Если КафкаПовтИсп.ЭтоБэкап() И Не КафкаПереопределяемый.РазрешенОбменБэкапов() Тогда
		ТекстСообщения = "Обмен бэкапов запрещен. Загрузка не будет запущена.";
		КафкаКлиентСервер.СообщитьПользователю(ТекстСообщения);
		ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+Шина, УровеньЖурналаРегистрации.Предупреждение, , , ТекстСообщения);
		Возврат;
	КонецЕсли;
	
	Загрузить(Шина);
	
КонецПроцедуры

Процедура Загрузить(Шина) Экспорт
	
	МоментСтарта = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	ШинаИнфо = ШинаИнфо(Шина);
	Если ШинаИнфо = Неопределено Тогда
		ВызватьИсключение "Некорректная шина.";
	КонецЕсли;
	
	Если ШинаИнфо.ОбменДлительностьСеанса <> 0 Тогда
		МоментЗавершения = МоментСтарта + ШинаИнфо.ОбменДлительностьСеанса;
	КонецЕсли;
	
	// Инициализируем API Кафки.
	Кафка = КафкаКлиентСервер.Адаптер(ШинаИнфо.Кластер);
	
	// Создаем экземпляр AdminClient для получения перечня читаемых разделов в соответствии с шаблоном темы.
	AdminClientConfig = КонфигурацияБазовая(ШинаИнфо.Кластер);
	AdminClient = Кафка.AdminCreate(ШинаИнфо.Наименование, AdminClientConfig, ШинаИнфо.КлиентТаймаут);
	Если AdminClient = Неопределено Тогда
		ВызватьИсключение Кафка.ОписаниеОшибки;
	КонецЕсли;
	
	// Формируем масив разделов, из которых будем читать сообщения.
	Попытка
		Partitions = ПолучитьЧитаемыеРазделы(Кафка, AdminClient, ШинаИнфо.Тема);
		Кафка.AdminRelease(AdminClient.Id, AdminClient.Token);
	Исключение
		Кафка.AdminRelease(AdminClient.Id, AdminClient.Token);
		ВызватьИсключение;
	КонецПопытки;
	
	Если Partitions.Количество() = 0 Тогда
		ВызватьИсключение "Не найдены темы Кафки, соответствующие предоставленному шаблону.";
	КонецЕсли;
	
	// Инициализируем массив потоков.
	КоличествоПотоков = Макс(ШинаИнфо.ОбменКоличествоПотоков, 1);
	КоличествоПотоков = Мин(КоличествоПотоков, Partitions.Количество());
	Потоки = Новый Массив;
	Для НомерПотока = 1 По КоличествоПотоков Цикл
		Поток = Новый Структура;
		Поток.Вставить("Номер", НомерПотока);
		Поток.Вставить("Partitions", Новый Массив);
		Потоки.Добавить(Поток);
	КонецЦикла;
		
	// Произвольным (но равномерным) образом распределяем читаемые разделы по потокам.
	ГенераторСлучайныхЧисел = Новый ГенераторСлучайныхЧисел;
	РазделовОсталось = Partitions.Количество();
	Пока Истина Цикл
		Для Каждого Поток Из Потоки Цикл
			Индекс = ГенераторСлучайныхЧисел.СлучайноеЧисло(0, РазделовОсталось-1);
			TopicPartition = Partitions[Индекс];
			Поток.Partitions.Добавить(TopicPartition);
			Partitions.Удалить(Индекс);
			РазделовОсталось = РазделовОсталось - 1;
			Если РазделовОсталось = 0 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если РазделовОсталось = 0 Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	// Инициализируем параметры получателя.
	ConsumerConfig = КонфигурацияШины(ШинаИнфо.Ссылка);
	Если ConsumerConfig.Получить("group.id") = Неопределено Тогда 
		ConsumerConfig.Вставить("group.id", КафкаПовтИсп.ГруппаПолучателей());
	КонецЕсли;
	ConsumerConfig.Вставить("enable.partition.eof", XMLСтрока(Не ШинаИнфо.ПриемВРеальномВремени));
	
	Если КоличествоПотоков > 1 Тогда
		
		// Определим идентификатор текущего фонового задания для того, чтобы в случае, если текущее задание
		// неожиданно завершится, дочерние задания смогли это определить, и также завершиться.
		ТекущийСеансИБ = ПолучитьТекущийСеансИнформационнойБазы();
		ТекущееФЗ = ТекущийСеансИБ.ПолучитьФоновоеЗадание();
		Если ТекущееФЗ <> Неопределено Тогда
			ИдентификаторТекущегоФЗ = ТекущееФЗ.УникальныйИдентификатор;
		Иначе
			ИдентификаторТекущегоФЗ = Неопределено;
		КонецЕсли;
		
		МассивЗаданий = Новый Массив;
		
		// Несколько потоков - запустим каждый в отдельном сеансе.
		Для Каждого Поток Из Потоки Цикл
						
			ЗаданиеПараметры = Новый Массив;
			ЗаданиеПараметры.Добавить(ШинаИнфо);
			ЗаданиеПараметры.Добавить(ConsumerConfig);
			ЗаданиеПараметры.Добавить(Поток);
			ЗаданиеПараметры.Добавить(МоментЗавершения);
			ЗаданиеПараметры.Добавить(ИдентификаторТекущегоФЗ);
			
			ЗаданиеКлюч = "КафкаСервер.ЗагрузитьРазделы-"
					+ Строка(ШинаИнфо.Ссылка.УникальныйИдентификатор()) + "-"
					+ Формат(Поток.Номер, "ЧЦ=3; ЧДЦ=0; ЧН=000");
					
			ЗаданиеНаименование = ШинаИнфо.Наименование+" ("+Поток.Номер+")";
					
			Задание = ФоновыеЗадания.Выполнить("КафкаСервер.ЗагрузитьРазделы", ЗаданиеПараметры, ЗаданиеКлюч, ЗаданиеНаименование);
			
			МассивЗаданий.Добавить(Задание);
			
		КонецЦикла;
		
		Ошибки = Новый Массив;
		
		Пока МассивЗаданий.Количество() > 0 Цикл
		
			МассивЗаданий = ФоновыеЗадания.ОжидатьЗавершенияВыполнения(МассивЗаданий, 5);
			
			Индекс = МассивЗаданий.Количество();
			Пока Индекс > 0 Цикл
				
				Индекс = Индекс - 1;
				Задание = МассивЗаданий[Индекс];
				
				Если Задание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
					Продолжить;
				КонецЕсли;
				
				МассивЗаданий.Удалить(Индекс);
				
				Если Задание.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда
					Ошибки.Добавить(Задание.ИнформацияОбОшибке);
				ИначеЕсли Задание.Состояние = СостояниеФоновогоЗадания.Отменено Тогда
					ОписаниеОшибки = "Один из потоков был вручную отменен.";
					ЗаписьЖурналаРегистрации(
							"Обмен данными.Кафка."+ШинаИнфо.Наименование,
							УровеньЖурналаРегистрации.Предупреждение,
							ШинаИнфо.Ссылка.Метаданные(),
							ШинаИнфо.Ссылка,
							ОписаниеОшибки);
				КонецЕсли;
						
			КонецЦикла;
			
		КонецЦикла;
		
		Если Ошибки.Количество() > 0 Тогда
			МассивОписаниеОшибки = Новый Массив;
			МассивОписаниеОшибки.Добавить("Один или несколько потоков загрузки завершились ошибками.");
			Для Каждого ИнформацияОбОшибке Из Ошибки Цикл
				Если ИнформацияОбОшибке = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				МассивОписаниеОшибки.Добавить(Символы.ПС);
				МассивОписаниеОшибки.Добавить(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
			КонецЦикла;
			ВызватьИсключение СтрСоединить(МассивОписаниеОшибки, Символы.ПС);
		КонецЕсли;
		
	Иначе
		
		// Один поток - запустим в текущем сеансе.
		Для Каждого Поток Из Потоки Цикл
			ЗагрузитьРазделы(ШинаИнфо, ConsumerConfig, Поток, МоментЗавершения);
		КонецЦикла;
		
	КонецЕсли;
		
КонецПроцедуры

Функция ПолучитьЧитаемыеРазделы(Кафка, AdminClient, Тема)
	
	Partitions = Новый Массив;
	
	Если СтрЗаканчиваетсяНа(Тема, "*") Тогда
		
		Md = Кафка.AdminGetMetadata(AdminClient.Id, AdminClient.Token);
		Если Md = Неопределено Тогда
			ВызватьИсключение Кафка.ОписаниеОшибки;
		КонецЕсли;
		
		ТемаПрефикс = Лев(Тема, СтрДлина(Тема)-1);
		
		Для Каждого TopicMd Из Md.Topics Цикл
			
			Если СтрНачинаетсяС(TopicMd.Topic, ТемаПрефикс) Тогда
				
				Для Каждого PartitionMd Из TopicMd.Partitions Цикл
					
					Partitions.Добавить(Новый Структура("Topic, Partition", TopicMd.Topic, PartitionMd.Partition));
					
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЦикла;
		
	Иначе
		
		Md = Кафка.AdminGetMetadata(AdminClient.Id, AdminClient.Token, Тема);
		Если Md = Неопределено Тогда
			ВызватьИсключение Кафка.ОписаниеОшибки;
		КонецЕсли;
		
		Для Каждого TopicMd Из Md.Topics Цикл
			
			Для Каждого PartitionMd Из TopicMd.Partitions Цикл
				
				Partitions.Добавить(Новый Структура("Topic, Partition", TopicMd.Topic, PartitionMd.Partition));
				
			КонецЦикла;
				
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Partitions;
	
КонецФункции

Процедура ЗагрузитьРазделы(ШинаИнфо, ConsumerConfig, Параметры, МоментЗавершения, ИдентификаторРодительскогоФЗ=Неопределено) Экспорт
	
	// Инициализируем API Кафки.
	Кафка = КафкаКлиентСервер.Адаптер(ШинаИнфо.Кластер);
	
	// Инициализируем обработку загрузки данных.
	Обработка = КафкаПереопределяемый.ПолучитьОбработку(ШинаИнфо);
	Если Обработка = Неопределено Тогда
		ВызватьИсключение "Не удалось инициализировать обработку обмена для шины """+ШинаИнфо.Наименование+""".";
	КонецЕсли;
	
	// Установим реквизиты обработки.
	ПотенциальныеРеквизитыОбработки = Новый Структура;
	ПотенциальныеРеквизитыОбработки.Вставить("Узел", ШинаИнфо.Узел);
	ПотенциальныеРеквизитыОбработки.Вставить("Шина", ШинаИнфо.Ссылка);
	УстановитьРеквизитыОбработки(Обработка, ПотенциальныеРеквизитыОбработки);
	
	// Если по каким-то (или всем) разделам загрузка запрещена, удаляем разделы из массива.
	Индекс = Параметры.Partitions.Количество();
	Пока Индекс > 0 Цикл
		Индекс = Индекс - 1;
		TopicPartition = Параметры.Partitions[Индекс];
		Если Не Обработка.ПередЗагрузкойРаздела(TopicPartition.Topic, TopicPartition.Partition, Кафка) Тогда
			Параметры.Partitions.Удалить(Индекс);
		КонецЕсли;
	КонецЦикла;
	
	ОбъектыСчетчик = 0;
	
	// Создаем экземпляр получателя внутри прокси, который будет читать сообщения для нас.
	Consumer = Кафка.ConsumerCreate(
			ШинаИнфо.Наименование+" ("+Параметры.Номер+")",
			ConsumerConfig,
			KeyValueType(ШинаИнфо.КлючСердес),
			KeyValueType(ШинаИнфо.ЗначениеСердес),
			ШинаИнфо.КлиентТаймаут
	);
	Если Consumer = Неопределено Тогда
		ВызватьИсключение Кафка.ОписаниеОшибки;
	КонецЕсли;
	
	// Конструкция, гарантирующая удаление экземпляра получателя независимо от того, чем завершится чтение.
	Попытка
				
		Если Параметры.Partitions.Количество() > 0 Тогда
			ЗагрузитьРазделы_(ШинаИнфо, Обработка, Кафка, Consumer, Параметры.Partitions, МоментЗавершения, ОбъектыСчетчик, ИдентификаторРодительскогоФЗ);
		КонецЕсли;
		
		Кафка.ConsumerRelease(Consumer.Id, Consumer.Token);
		
	Исключение
		
		Кафка.ConsumerRelease(Consumer.Id, Consumer.Token);
		ВызватьИсключение;
		
	КонецПопытки;
		
КонецПроцедуры

Процедура ЗагрузитьРазделы_(ШинаИнфо, Обработка, Кафка, Consumer, Assignment, МоментЗавершения, ОбъектыСчетчик, ИдентификаторРодительскогоФЗ)
	
	ЕстьНовыеСообщения = Ложь;
	
	СостоянияЧтения = Новый Соответствие;
	
	Для Каждого TopicPartition Из Assignment Цикл
				
		// Получаем начальное и конечное смещения раздела.
		PartitionOffsets = Кафка.ConsumerQueryPartitionOffsets(Consumer.Id, Consumer.Token, TopicPartition.Topic, TopicPartition.Partition);
		Если PartitionOffsets = Неопределено Тогда
			ВызватьИсключение Кафка.ОписаниеОшибки;
		КонецЕсли;
		
		// Получаем последнюю зафиксированную позицию чтения.
		ТекущаяПозиция = РегистрыСведений.КафкаПозиции.ПолучитьПозицию(ШинаИнфо.Кластер, TopicPartition.Topic, TopicPartition.Partition);
		
		// Проверка корректности текущей позиции
		Если ТекущаяПозиция < PartitionOffsets.Low Тогда
			ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
					УровеньЖурналаРегистрации.Предупреждение, , TopicPartition.Topic+":"+Формат(TopicPartition.Partition, "ЧН=0; ЧГ=0"),
					"Начальная позиция раздела ("+Формат(PartitionOffsets.Low, "ЧН=0")+") больше текущей ("+Формат(ТекущаяПозиция, "ЧН=0")+"). Текущая позиция будет скорректирована.");
			ТекущаяПозиция = PartitionOffsets.Low;
		ИначеЕсли ТекущаяПозиция > PartitionOffsets.High Тогда
			ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
					УровеньЖурналаРегистрации.Предупреждение, , TopicPartition.Topic+":"+Формат(TopicPartition.Partition, "ЧН=0; ЧГ=0"),
					"Конечная позиция раздела ("+Формат(PartitionOffsets.High, "ЧН=0")+") меньше текущей ("+Формат(ТекущаяПозиция, "ЧН=0")+"). Текущая позиция будет скорректирована.");
			ТекущаяПозиция = PartitionOffsets.High;
		КонецЕсли;
		
		// Установим начальную позицию, с которой будут прочитаны сообщения раздела.
		TopicPartition.Вставить("Offset", ТекущаяПозиция);
		
		СостоянияЧтенияТопика = СостоянияЧтения.Получить(TopicPartition.Topic);
		Если СостоянияЧтенияТопика = Неопределено Тогда
			СостоянияЧтенияТопика = Новый Соответствие;
			СостоянияЧтения.Вставить(TopicPartition.Topic, СостоянияЧтенияТопика);
		КонецЕсли;
		
		СостояниеЧтенияРаздела = Новый Структура("НачальноеСмещение, КонечноеСмещение, ТекущаяПозиция", PartitionOffsets.Low, PartitionOffsets.High, ТекущаяПозиция);
		СостояниеЧтенияРаздела.Вставить("НачальноеСмещение"	, PartitionOffsets.Low);
		СостояниеЧтенияРаздела.Вставить("КонечноеСмещение"	, PartitionOffsets.High);
		СостояниеЧтенияРаздела.Вставить("ТекущаяПозиция"	, ТекущаяПозиция);
		
		СостоянияЧтенияТопика.Вставить(TopicPartition.Partition, СостояниеЧтенияРаздела);
		
		ЕстьНовыеСообщения = ЕстьНовыеСообщения Или (ТекущаяПозиция<PartitionOffsets.High);
		
	КонецЦикла;
	
	// Если длительность приема равна нулю и нет новых сообщений,
	// нет смысла инициировать получение сообщений.
	Если ЕстьНовыеСообщения Или ШинаИнфо.ОбменДлительностьСеанса > 0 Тогда
		
		ТекущийМомент = ТекущаяУниверсальнаяДатаВМиллисекундах();
		Для Каждого TopicPartition Из Assignment Цикл
			
			СостояниеЧтенияРаздела = СостоянияЧтения[TopicPartition.Topic][TopicPartition.Partition];
			СостояниеЧтенияРаздела.Вставить("ПолученоСообщенийПослеПоследнейФиксации", 0);
			СостояниеЧтенияРаздела.Вставить("МоментПоследнейФиксации", ТекущийМомент);
			
			ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
					УровеньЖурналаРегистрации.Информация, , TopicPartition.Topic+":"+Формат(TopicPartition.Partition, "ЧН=0; ЧГ=0"),
					"Начато чтение раздела. Начальная позиция: "+Формат(СостояниеЧтенияРаздела.ТекущаяПозиция, "ЧН=0")+".");
			
		КонецЦикла;
		
		// Назначим получателя читать сообщения из переданных топиков-разделов
		Assignment = Кафка.ConsumerAssign(Consumer.Id, Consumer.Token, Assignment);
		Если Assignment = Неопределено Тогда
			ВызватьИсключение Кафка.ОписаниеОшибки;
		КонецЕсли;
		
		ИмяПроцедурыЗагрузки = "Обработка." + ШинаИнфо.ПриемПроцедура + "(Сообщение)";
		
		ОсталосьРазделов = Assignment.Количество();
		
		МоментПоследнейПроверкиНеобходимостиЗавершения = Неопределено;
		
		Пока Истина Цикл
						
			Попытка
			
				// Получим новое сообщение.
				Message = Кафка.ConsumerConsume(Consumer.Id, Consumer.Token, ШинаИнфо.ПриемТаймаутОжидания);
				
				Если Message = Неопределено Тогда
					ВызватьИсключение Кафка.ОписаниеОшибки;
				КонецЕсли;
			
			Исключение
				ЗафиксироватьПозицииЧтения(Assignment, СостоянияЧтения, ШинаИнфо, Обработка);
				ВызватьИсключение;
			КонецПопытки;
			
			Если Message <> Null И Не Message.IsPartitionEOF Тогда

				СостояниеЧтенияРаздела = СостоянияЧтения[Message.Topic][Message.Partition];
				
				//Если Message.Offset < СостояниеЧтенияРаздела.ТекущаяПозиция Тогда
				//	ЗафиксироватьПозицииЧтения(Assignment, СостоянияЧтения, ШинаИнфо, Обработка);					
				//	ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
				//			УровеньЖурналаРегистрации.Предупреждение, , Message.Topic+":"+Формат(Message.Partition, "ЧН=0; ЧГ=0"),
				//			"Позиция полученного сообщения ("+Формат(Message.Offset, "ЧН=0")+") меньше текущей ("+Формат(СостояниеЧтенияРаздела.ТекущаяПозиция, "ЧН=0")+").");
				//	ВызватьИсключение "Обнаружено нарушение последовательности чтения данных. Подробности в журнале регистрации по номеру сеанса.";
				//ИначеЕсли Message.Offset > СостояниеЧтенияРаздела.ТекущаяПозиция Тогда
				//	ЗафиксироватьПозицииЧтения(Assignment, СостоянияЧтения, ШинаИнфо, Обработка);
				//	ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
				//			УровеньЖурналаРегистрации.Предупреждение, , Message.Topic+":"+Формат(Message.Partition, "ЧН=0; ЧГ=0"),
				//			"Позиция полученного сообщения ("+Формат(Message.Offset, "ЧН=0")+") больше текущей ("+Формат(СостояниеЧтенияРаздела.ТекущаяПозиция, "ЧН=0")+").");
				//	ВызватьИсключение "Обнаружено нарушение последовательности чтения данных. Подробности в журнале регистрации по номеру сеанса.";
				//КонецЕсли;
								
				Попытка
					
					Сообщение = Новый Структура;
					Сообщение.Вставить("Тема", Message.Topic);
					Сообщение.Вставить("Раздел", Message.Partition);
					Сообщение.Вставить("Смещение", Message.Offset);
					Сообщение.Вставить("ОтметкаВремени", Message.Timestamp);
					Сообщение.Вставить("Заголовки", Message.Headers);
					Сообщение.Вставить("Ключ", ДесериализоватьИзСтроки(Message.Key, ШинаИнфо.КлючСердес));
					Сообщение.Вставить("Значение", ДесериализоватьИзСтроки(Message.Value, ШинаИнфо.ЗначениеСердес));
					
					Выполнить(ИмяПроцедурыЗагрузки);
					
				Исключение
					ЗафиксироватьПозицииЧтения(Assignment, СостоянияЧтения, ШинаИнфо, Обработка);
					ВызватьИсключение;
				КонецПопытки;
				
				// Обновление состояния чтения текущего раздела.
				СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации = СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации + 1;
				СостояниеЧтенияРаздела.ТекущаяПозиция = Message.Offset + 1;
				
				ОбъектыСчетчик = ОбъектыСчетчик + 1;
				
			КонецЕсли;
			
			ТекущийМомент = ТекущаяУниверсальнаяДатаВМиллисекундах();
			
			// Периодически проверяем необходимость завершения текущего сеанса. Если необходимо - прекращаем чтение.
			Если НеобходимоЗавершитьОперацию(ТекущийМомент, МоментПоследнейПроверкиНеобходимостиЗавершения, МоментЗавершения, ИдентификаторРодительскогоФЗ) Тогда
				Прервать;
			КонецЕсли;
			
			Если ШинаИнфо.ПриемВРеальномВремени Тогда
				
				// Если долго не получаем новых сообщений, надо периодически проверять наличие незафиксированных позиций.
				Если Message = Null Тогда
					ЗафиксироватьПозицииЧтения(Assignment, СостоянияЧтения, ШинаИнфо, Обработка);
				КонецЕсли;
								
			Иначе
				
				Если Message = Null Тогда
					// Завершаем загрузку в случае отсутствия новых сообщений.
					Прервать;
				ИначеЕсли Message.IsPartitionEOF Тогда
					ОсталосьРазделов = ОсталосьРазделов - 1;
					Если ОсталосьРазделов = 0 Тогда
						// От всех разделов были получены маркеры отсутствия новых сообщений. Завершаем чтение.
						Прервать;
					КонецЕсли;
				КонецЕсли;
				
			КонецЕсли;
			
			Если Message <> Null И Не Message.IsPartitionEOF Тогда
				// Фиксируем текущую позицию чтения каждые 500 сообщений или каждые 20 секунд, смотря что наступит раньше.
				Если СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации >= 500
				Или ТекущийМомент - СостояниеЧтенияРаздела.МоментПоследнейФиксации >= 20000 Тогда
					ЗафиксироватьПозициюЧтения(ШинаИнфо.Кластер, Message.Topic, Message.Partition, СостояниеЧтенияРаздела, Обработка);
				КонецЕсли;
			КонецЕсли;
						
		КонецЦикла;
		
		Для Каждого TopicPartition Из Assignment Цикл
			
			СостояниеЧтенияРаздела = СостоянияЧтения[TopicPartition.Topic][TopicPartition.Partition];
			
			// Финальная фиксация текущей позиции чтения.
			ЗафиксироватьПозициюЧтения(ШинаИнфо.Кластер, TopicPartition.Topic, TopicPartition.Partition, СостояниеЧтенияРаздела, Обработка);
			
			ЗаписьЖурналаРегистрации("Обмен данными.Кафка."+ШинаИнфо.Наименование,
			УровеньЖурналаРегистрации.Информация, , TopicPartition.Topic+":"+Формат(TopicPartition.Partition, "ЧН=0; ЧГ=0"),
			"Завершено чтение раздела. Конечная позиция: "+Формат(СостояниеЧтенияРаздела.ТекущаяПозиция, "ЧН=0")+".");
			
			РегистрыСведений.КафкаПозиции.УдалитьСтарые(ШинаИнфо.Кластер, TopicPartition.Topic, TopicPartition.Partition);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Для Каждого TopicPartition Из Assignment Цикл
		СостояниеЧтенияРаздела = СостоянияЧтения[TopicPartition.Topic][TopicPartition.Partition];
		Обработка.ПослеЗагрузкиРаздела(TopicPartition.Topic, TopicPartition.Partition, СостояниеЧтенияРаздела.ТекущаяПозиция);
	КонецЦикла;
	
КонецПроцедуры

Функция ДесериализоватьИзСтроки(ЗначениеСтрока, Сердес, СхемаИмя=Неопределено, СхемаПространствоИмен=Неопределено)
	
	Если Сердес = Перечисления.КафкаСердес.Игнорировать Тогда
		
		Возврат Неопределено;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Null Тогда
		
		Если ЗначениеСтрока <> Неопределено Тогда
			ВызватьИсключение "Некорректный тип исходных данных для десериализации.";
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.ДвоичныеДанные Тогда
		
		Если ЗначениеСтрока = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Возврат ПолучитьДвоичныеДанныеИзBase64Строки(ЗначениеСтрока);
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Uuid Тогда
		
		Если ЗначениеСтрока = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Возврат Новый УникальныйИдентификатор(ЗначениеСтрока);
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Строка Тогда
		
		Если ЗначениеСтрока = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Возврат ЗначениеСтрока;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СтрокаAvro Тогда
		
		Если ЗначениеСтрока = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Возврат ЗначениеСтрока;
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СтруктураAvro Тогда
		
		Если ЗначениеСтрока = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Возврат КафкаКлиентСервер.AvroДесериализовать(ЗначениеСтрока, СхемаИмя, СхемаПространствоИмен);
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СтруктураJson Тогда
		
		Если ЗначениеСтрока = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Возврат КафкаКлиентСервер.JsonДесериализовать(ЗначениеСтрока, Ложь);
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СоответствиеJson Тогда
		
		Если ЗначениеСтрока = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Возврат КафкаКлиентСервер.JsonДесериализовать(ЗначениеСтрока, Истина);
		
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Xml Тогда
		
		Если ЗначениеСтрока = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Возврат КафкаКлиентСервер.XmlДесериализовать(ЗначениеСтрока);
		
	Иначе
		ВызватьИсключение "Неожиданнный/неподдерживаемый способ десериализации: """+Сердес+"""."
	КонецЕсли;
	
КонецФункции

Процедура ЗафиксироватьПозицииЧтения(Assignment, СостоянияЧтения, ШинаИнфо, Обработка)
	
	Для Каждого TopicPartition Из Assignment Цикл
		СостояниеЧтенияРаздела = СостоянияЧтения[TopicPartition.Topic][TopicPartition.Partition];
		ЗафиксироватьПозициюЧтения(ШинаИнфо.Кластер, TopicPartition.Topic, TopicPartition.Partition, СостояниеЧтенияРаздела, Обработка);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗафиксироватьПозициюЧтения(Кластер, Тема, Раздел, СостояниеЧтенияРаздела, Обработка)
	
	Если СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации = 0 Тогда
		Возврат;
	КонецЕсли;
	
	//// В случае буферизации сообщений обработкой нужно синхронизировать сброс буфера и фиксацию позиции чтения.
	//Обработка.СброситьБуферы();
	
	Если ТранзакцияАктивна() Тогда
		ВызватьИсключение "Во время фиксации позиции чтения транзакция не должна быть активна.";
	КонецЕсли;
	
	РегистрыСведений.КафкаПозиции.УстановитьПозицию(Кластер, Тема, Раздел, СостояниеЧтенияРаздела.ТекущаяПозиция);
	
	СостояниеЧтенияРаздела.ПолученоСообщенийПослеПоследнейФиксации = 0;
	СостояниеЧтенияРаздела.МоментПоследнейФиксации = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
КонецПроцедуры

Функция НеобходимоЗавершитьОперацию(ТекущийМомент, МоментПоследнейПроверки, МоментЗавершения, ИдентификаторРодительскогоФЗ)
		
	Если МоментЗавершения <> Неопределено И ТекущийМомент >= МоментЗавершения Тогда
		// Завершаем операцию по истечению максимальной длительности.
		Возврат Истина;
	КонецЕсли;
	
	Если МоментПоследнейПроверки = Неопределено Тогда
		МоментПоследнейПроверки = ТекущийМомент;
	КонецЕсли;
	
	Если ТекущийМомент - МоментПоследнейПроверки > 20000 Тогда
		
		МоментПоследнейПроверки = ТекущийМомент;

		Если ИдентификаторРодительскогоФЗ <> Неопределено Тогда
			РодительскоеФЗ = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(ИдентификаторРодительскогоФЗ);
			Если РодительскоеФЗ = Неопределено Или РодительскоеФЗ.Состояние <> СостояниеФоновогоЗадания.Активно Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
		
		НеобходимостьЗавершенияСоединения = НеобходимостьЗавершенияСоединения();
		Если НеобходимостьЗавершенияСоединения.НеобходимоЗавершить Тогда
			Возврат Истина;
		КонецЕсли;
		
	КонецЕсли;
		
	Возврат Ложь;
	
КонецФункции

#КонецОбласти

#Область СлужебныеФункции

Функция KeyValueType(Сердес)
	
	Если Сердес = Перечисления.КафкаСердес.Игнорировать Тогда
		Возврат "Ignore";
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Null Тогда
		Возврат "Null";
	ИначеЕсли Сердес = Перечисления.КафкаСердес.ДвоичныеДанные Тогда
		Возврат "Bytes";
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Uuid Тогда
		Возврат "String";
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Строка Тогда
		Возврат "String";
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СтрокаAvro Тогда
		Возврат "Avro";
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СтруктураAvro Тогда
		Возврат "Avro";
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СтруктураJson Тогда
		Возврат "String";
	ИначеЕсли Сердес = Перечисления.КафкаСердес.СоответствиеJson Тогда
		Возврат "String";
	ИначеЕсли Сердес = Перечисления.КафкаСердес.Xml Тогда
		Возврат "String";
	Иначе
		ВызватьИсключение "Неожиданный способ (де)сериализаци: """+Сердес+""".";
	КонецЕсли;
	
КонецФункции

Функция КонфигурацияБазовая(Кластер) Экспорт
	
	КластерСсылка = ?(Кластер=Неопределено, Справочники.КафкаКластеры.ПоУмолчанию, Кластер);
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Кластеры.КафкаСерверы КАК Серверы,
	|	Кластеры.КафкаПротоколБезопасности КАК ПротоколБезопасности,
	|	Кластеры.КафкаПользователь КАК Пользователь,
	|	Кластеры.КафкаПользовательУстановлен КАК ПользовательУстановлен,
	|	Кластеры.КафкаПароль КАК Пароль
	|ИЗ
	|	Справочник.КафкаКластеры КАК Кластеры
	|ГДЕ
	|	Кластеры.Ссылка = &Кластер");
	Запрос.УстановитьПараметр("Кластер", КластерСсылка);
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		ВызватьИсключение "Передан некорректный параметр.";
	КонецЕсли;
	
	КластерРеквизиты = РезультатЗапроса.Выгрузить()[0];
	
	Результат = Новый Соответствие;
		
	Результат.Вставить("bootstrap.servers", КластерРеквизиты.Серверы);
	Результат.Вставить("security.protocol", КластерРеквизиты.ПротоколБезопасности);
	Если СтрНачинаетсяС(ВРег(КластерРеквизиты.ПротоколБезопасности), "SASL") Тогда
		Результат.Вставить("sasl.mechanism", "PLAIN");
		Если КластерРеквизиты.ПользовательУстановлен Тогда
			Результат.Вставить("sasl.username", КластерРеквизиты.Пользователь);
		Иначе
			Результат.Вставить("sasl.username", КафкаПереопределяемый.ПользовательПоУмолчанию());
		КонецЕсли;
		Результат.Вставить("sasl.password", КластерРеквизиты.Пароль);
	КонецЕсли;
		
	Возврат Результат;
			
КонецФункции

Функция КонфигурацияОтправителя(Кластер=Неопределено) Экспорт
	
	КластерСсылка = ?(Кластер=Неопределено, Справочники.КафкаКластеры.ПоУмолчанию, Кластер);
	
	Результат = КонфигурацияБазовая(КластерСсылка);
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Конфигурация.Параметр КАК Параметр,
	|	Конфигурация.Значение КАК Значение
	|ИЗ
	|	Справочник.КафкаКластеры.КафкаКонфигурацияОтправителя КАК Конфигурация
	|ГДЕ
	|	Конфигурация.Ссылка = &Кластер");
	Запрос.УстановитьПараметр("Кластер", КластерСсылка);
	РезультатЗапроса = Запрос.Выполнить();
			
	ТЗ = РезультатЗапроса.Выгрузить();
	Для Каждого С Из ТЗ Цикл
		Результат.Вставить(С.Параметр, С.Значение);
	КонецЦикла;
	
	Возврат Результат;
			
КонецФункции

Функция КонфигурацияПолучателя(Кластер=Неопределено) Экспорт
	
	КластерСсылка = ?(Кластер=Неопределено, Справочники.КафкаКластеры.ПоУмолчанию, Кластер);
	
	Результат = КонфигурацияБазовая(КластерСсылка);
	
	Результат.Вставить("group.id", КафкаПереопределяемый.ГруппаПолучателей());
	Результат.Вставить("auto.offset.reset", "earliest");
	Результат.Вставить("enable.auto.commit", "false");
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Конфигурация.Параметр КАК Параметр,
	|	Конфигурация.Значение КАК Значение
	|ИЗ
	|	Справочник.КафкаКластеры.КафкаКонфигурацияПолучателя КАК Конфигурация
	|ГДЕ
	|	Конфигурация.Ссылка = &Кластер");
	Запрос.УстановитьПараметр("Кластер", КластерСсылка);
	РезультатЗапроса = Запрос.Выполнить();
			
	ТЗ = РезультатЗапроса.Выгрузить();
	Для Каждого С Из ТЗ Цикл
		Результат.Вставить(С.Параметр, С.Значение);
	КонецЦикла;
	
	Возврат Результат;
			
КонецФункции

Функция КонфигурацияШины(Шина) Экспорт
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Шины.Ссылка КАК Ссылка,
	|	Шины.Кластер КАК Кластер,
	|	Шины.ОбменНаправление КАК ОбменНаправление
	|ИЗ
	|	Справочник.КафкаШины КАК Шины
	|ГДЕ
	|	Шины.Ссылка = &Шина
	|	И НЕ Шины.ЭтоГруппа
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Конфигурация.Параметр КАК Параметр,
	|	Конфигурация.Значение КАК Значение
	|ИЗ
	|	Справочник.КафкаШины.КафкаКонфигурация КАК Конфигурация
	|ГДЕ
	|	Конфигурация.Ссылка = &Шина");
	Запрос.УстановитьПараметр("Шина", Шина);
	РезультатЗапроса = Запрос.ВыполнитьПакет();
	
	Если РезультатЗапроса[0].Пустой() Тогда
		ВызватьИсключение "Передан некорректный параметр.";
	КонецЕсли;
	
	ШинаРеквизиты = РезультатЗапроса[0].Выгрузить()[0];
	
	Если ШинаРеквизиты.ОбменНаправление = Перечисления.КафкаНаправленияОбмена.Выгрузка Тогда
		Результат = КонфигурацияОтправителя(ШинаРеквизиты.Кластер);
	ИначеЕсли ШинаРеквизиты.ОбменНаправление = Перечисления.КафкаНаправленияОбмена.Загрузка Тогда
		Результат = КонфигурацияПолучателя(ШинаРеквизиты.Кластер);
	Иначе
		ВызватьИсключение "Неожиданное направление обмена: """+ШинаРеквизиты.ОбменНаправление+""".";
	КонецЕсли;
			
	ТЗ = РезультатЗапроса[1].Выгрузить();
	Для Каждого С Из ТЗ Цикл
		Результат.Вставить(С.Параметр, С.Значение);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура УстановитьРеквизитыОбработки(Обработка, ПотенциальныеРеквизиты)
	
	ОбработкаМетаданные = Обработка.Метаданные();
	
	Для Каждого КЗ Из ПотенциальныеРеквизиты Цикл
		
		ОбработкаРеквизит = ОбработкаМетаданные.Реквизиты.Найти(КЗ.Ключ);
		
		Если ОбработкаРеквизит <> Неопределено Тогда
			
			ЗначениеПравое = КЗ.Значение;
			Обработка[КЗ.Ключ] = ЗначениеПравое;
			ЗначениеЛевое = Обработка[КЗ.Ключ]; 
			
			Если Не ЗначениеЗаполнено(ЗначениеЛевое) И Не ЗначениеЗаполнено(ЗначениеПравое) Тогда
			ИначеЕсли ЗначениеЛевое <> ЗначениеПравое Тогда
				ВызватьИсключение "Не удалось установить реквизит """+КЗ.Ключ+""" при иницилизации обработки выгрузки/загрузки данных.";
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ШинаИнфо(Шина) Экспорт
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Шины.Ссылка КАК Ссылка,
	|	Шины.ПометкаУдаления КАК ПометкаУдаления,
	|	Шины.Родитель КАК Родитель,
	|	Шины.ЭтоГруппа КАК ЭтоГруппа,
	|	Шины.Наименование КАК Наименование,
	|	Шины.Кластер КАК Кластер,
	|	Шины.ОбменНаправление КАК ОбменНаправление,
	|	Шины.Тема КАК Тема,
	|	Шины.Узел КАК Узел,
	|	Шины.КлючСердес КАК КлючСердес,
	|	Шины.ЗначениеСердес КАК ЗначениеСердес,
	|	Шины.ОбменДлительностьСеанса КАК ОбменДлительностьСеанса,
	|	Шины.ОбменКоличествоПотоков КАК ОбменКоличествоПотоков,
	|	Шины.ОбменПоРасписанию КАК ОбменПоРасписанию,
	|	Шины.ОбменРасписание КАК ОбменРасписание,
	|	Шины.ОбменРасписаниеРазброс КАК ОбменРасписаниеРазброс,
	|	Шины.Обработка КАК Обработка,
	|	Шины.КлиентТаймаут КАК КлиентТаймаут,
	|	Шины.ОтправкаБлокироватьТаблицуРегистрации КАК ОтправкаБлокироватьТаблицуРегистрации,
	|	Шины.ПриемПроцедура КАК ПриемПроцедура,
	|	Шины.ПриемВРеальномВремени КАК ПриемВРеальномВремени,
	|	Шины.ПриемТаймаутОжидания КАК ПриемТаймаутОжидания,
	|	ЕСТЬNULL(ЕСТЬNULL(Шины.ПользовательРЗ, Шины.Родитель.ПользовательРЗ), """") КАК ПользовательРЗ
	|ИЗ
	|	Справочник.КафкаШины КАК Шины
	|ГДЕ
	|	Шины.Ссылка = &Ссылка");
	Запрос.УстановитьПараметр("Ссылка", Шина);
	РезультатЗапроса = Запрос.ВыполнитьПакет();
	
	Если РезультатЗапроса[0].Пустой() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Структура;
	
	Шапка = РезультатЗапроса[0].Выгрузить()[0];
	Для Каждого Колонка Из РезультатЗапроса[0].Колонки Цикл
		Результат.Вставить(Колонка.Имя, Шапка[Колонка.Имя]);
	КонецЦикла;
		
	Результат.ОбменРасписание = Результат.ОбменРасписание.Получить();
	
	Результат.Тема = Тема(Результат.Тема);
	
	Результат.Вставить("ТемаЭтоПрефикс", СтрЗаканчиваетсяНа(Результат.Тема, "*"));
	Если Результат.ТемаЭтоПрефикс Тогда
		Результат.Вставить("ТемаПрефикс", Лев(Результат.Тема, СтрДлина(Результат.Тема)-1));
	КонецЕсли;
	
	Возврат Новый ФиксированнаяСтруктура(Результат);
	
КонецФункции

Процедура ОбновитьРегламентныеЗадания(ШинаСсылка, Удалить=Неопределено) Экспорт
		
	ШинаИнфо = ШинаИнфо(ШинаСсылка);
			
	МассивЗаданийОтправка = Новый Массив;
	м = РегламентныеЗадания.ПолучитьРегламентныеЗадания(Новый Структура("Метаданные", Метаданные.РегламентныеЗадания.КафкаВыгрузка));
	Для Каждого Задание Из м Цикл
		Если Задание.Параметры=Неопределено Или Задание.Параметры.Количество()=0 Или ТипЗнч(Задание.Параметры[0])<>Тип("СправочникСсылка.КафкаШины") Или Не ЗначениеЗаполнено(Задание.Параметры[0]) Тогда
			УдалитьРегламентноеЗадание(Задание);
		ИначеЕсли Задание.Параметры[0] = ШинаСсылка Тогда
			МассивЗаданийОтправка.Добавить(Задание);
		КонецЕсли;
	КонецЦикла;
	
	МассивЗаданийПрием = Новый Массив;
	м = РегламентныеЗадания.ПолучитьРегламентныеЗадания(Новый Структура("Метаданные", Метаданные.РегламентныеЗадания.КафкаЗагрузка));
	Для Каждого Задание Из м Цикл
		Если Задание.Параметры=Неопределено Или Задание.Параметры.Количество()=0 Или ТипЗнч(Задание.Параметры[0])<>Тип("СправочникСсылка.КафкаШины") Или Не ЗначениеЗаполнено(Задание.Параметры[0]) Тогда
			УдалитьРегламентноеЗадание(Задание);
		ИначеЕсли Задание.Параметры[0] = ШинаСсылка Тогда
			МассивЗаданийПрием.Добавить(Задание);
		КонецЕсли;
	КонецЦикла;
	
	Если Удалить = Истина Или ШинаИнфо.ПометкаУдаления Тогда
		Для Каждого Задание Из МассивЗаданийОтправка Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		Для Каждого Задание Из МассивЗаданийПрием Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		Возврат;
	КонецЕсли;
		
	Если ШинаИнфо.ОбменНаправление = Перечисления.КафкаНаправленияОбмена.Выгрузка Тогда
		
		Для Каждого Задание Из МассивЗаданийПрием Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		
		Задание = Неопределено;
		
		Если МассивЗаданийОтправка.Количество() > 0 Тогда
			Задание = МассивЗаданийОтправка.Получить(0);
			МассивЗаданийОтправка.Удалить(0);
		КонецЕсли;
		
		Для Каждого Задание_ Из МассивЗаданийОтправка Цикл
			УдалитьРегламентноеЗадание(Задание_);
		КонецЦикла;
		
		ОбновитьРегламентноеЗадание(ШинаИнфо, Задание);
							
	ИначеЕсли ШинаИнфо.ОбменНаправление = Перечисления.КафкаНаправленияОбмена.Загрузка Тогда
		
		Для Каждого Задание Из МассивЗаданийОтправка Цикл
			УдалитьРегламентноеЗадание(Задание);
		КонецЦикла;
		
		Задание = Неопределено;
		
		Если МассивЗаданийПрием.Количество() > 0 Тогда
			Задание = МассивЗаданийПрием.Получить(0);
			МассивЗаданийПрием.Удалить(0);
		КонецЕсли;
		
		Для Каждого Задание_ Из МассивЗаданийПрием Цикл
			УдалитьРегламентноеЗадание(Задание_);
		КонецЦикла;
		
		ОбновитьРегламентноеЗадание(ШинаИнфо, Задание);
											
	Иначе
		ВызватьИсключение "Неизвестное направление обмена шины: " + ШинаИнфо.ОбменНаправление;
	КонецЕсли;
	
КонецПроцедуры
Процедура ОбновитьРегламентноеЗадание(ШинаИнфо, Задание)
	
	Если ШинаИнфо.ОбменНаправление = Перечисления.КафкаНаправленияОбмена.Выгрузка Тогда
		ЗаданиеМетаданные = Метаданные.РегламентныеЗадания.КафкаВыгрузка;
	ИначеЕсли ШинаИнфо.ОбменНаправление = Перечисления.КафкаНаправленияОбмена.Загрузка Тогда
		ЗаданиеМетаданные = Метаданные.РегламентныеЗадания.КафкаЗагрузка;
	Иначе
		ВызватьИсключение "Неизвестное направление обмена шины: " + ШинаИнфо.ОбменНаправление;
	КонецЕсли;
	
	Если Задание = Неопределено Тогда
		Если ШинаИнфо.ПометкаУдаления Или Не ШинаИнфо.ОбменПоРасписанию Тогда
			Возврат;
		КонецЕсли;
		Задание = РегламентныеЗадания.СоздатьРегламентноеЗадание(ЗаданиеМетаданные);
	КонецЕсли;
	
	Расписание = Новый РасписаниеРегламентногоЗадания;
	ЗаполнитьЗначенияСвойств(Расписание, ШинаИнфо.ОбменРасписание);
	
	Если Расписание.ПериодПовтораВТечениеДня <> 0 И ШинаИнфо.ОбменРасписаниеРазброс <> 0 Тогда
		ГенераторСлучайныхЧисел = Новый ГенераторСлучайныхЧисел;
		Смещение = ГенераторСлучайныхЧисел.СлучайноеЧисло(0, ШинаИнфо.ОбменРасписаниеРазброс*2) - ШинаИнфо.ОбменРасписаниеРазброс;
		Расписание.ПериодПовтораВТечениеДня = Расписание.ПериодПовтораВТечениеДня + Смещение;
	КонецЕсли;
	
	Параметры = Новый Массив;
	Параметры.Добавить(ШинаИнфо.Ссылка);
	
	Задание.Параметры		= Параметры;
	Задание.Ключ			= ЗаданиеМетаданные.Ключ+"_"+ШинаИнфо.Ссылка.УникальныйИдентификатор();
	Задание.Наименование	= ЗаданиеМетаданные.Наименование+" ("+ШинаИнфо.Наименование+")";
	Задание.Расписание		= Расписание;
	Задание.Использование	= ШинаИнфо.ОбменПоРасписанию И Не ШинаИнфо.ПометкаУдаления;
	Задание.ИмяПользователя	= ШинаИнфо.ПользовательРЗ;
	
	Задание.Записать();
	
	Если Не Задание.Использование Тогда
		ОтменитьФоновоеЗадание(Задание);
	КонецЕсли;
	
КонецПроцедуры
Процедура УдалитьРегламентноеЗадание(РегламентноеЗадание) Экспорт
	
	Если РегламентноеЗадание.Использование Тогда
		РегламентноеЗадание.Использование = Ложь;
		РегламентноеЗадание.Записать();
	КонецЕсли;
	
	ОтменитьФоновоеЗадание(РегламентноеЗадание);
	
	РегламентноеЗадание.Удалить();
		
КонецПроцедуры
Процедура ОтменитьФоновоеЗадание(РегламентноеЗадание)
	
	Отбор = Новый Структура;
	Отбор.Вставить("РегламентноеЗадание", РегламентноеЗадание);
	Отбор.Вставить("Состояние", СостояниеФоновогоЗадания.Активно);
	
	АктивныеФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(Отбор);
		
	Для Каждого ФоновоеЗадание Из АктивныеФоновыеЗадания Цикл
		ФоновоеЗадание.Отменить();
	КонецЦикла;
	
КонецПроцедуры

Функция Тема(ИсходнаяТема) Экспорт
		
	Если КафкаПовтИсп.ЭтоБэкап() Тогда
		Возврат "test-" + ИсходнаяТема;
	КонецЕсли;
	
	Возврат ИсходнаяТема;
	
КонецФункции

Процедура ПолучитьСмещенияТемыВФоне(Кластер, Тема, АдресРезультата=Неопределено) Экспорт
	
	Кафка = КафкаКлиентСервер.Адаптер(Кластер);
	
	Операция = "Получение смещений темы """+Тема+"""";
	Конфигурация = КонфигурацияПолучателя(Кластер);
	Результат = Кафка.ПолучитьСмещенияТемы(Операция, Конфигурация, Тема);
	
	Если Результат <> Неопределено Тогда
		ОписаниеРезультата = Новый Структура("Успех, Результат", Истина, Результат);
	Иначе
		ОписаниеРезультата = Новый Структура("Успех, ОписаниеОшибки", Ложь, Кафка.ОписаниеОшибки);
	КонецЕсли;
	
	ПоместитьВоВременноеХранилище(ОписаниеРезультата, АдресРезультата);
	
КонецПроцедуры

Функция СтрокаСоединенияИБ() Экспорт
	
	Если КафкаПовтИсп.ЭтоФоновоеЗадание() Тогда
		Возврат СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	
	АдресРезультата = ПоместитьВоВременноеХранилище(Неопределено);
	
	Параметры = Новый Массив;
	Параметры.Добавить(АдресРезультата);
	
	Задание = ФоновыеЗадания.Выполнить(
			"КафкаСервер.ПолучитьСтрокуСоединенияИнформационнойБазыВФоне",
			Параметры,
			,
			"Кафка: Получение строки соединения информационной базы"
	);
	
	Пока Задание.Состояние = СостояниеФоновогоЗадания.Активно Цикл
		
		Задание = Задание.ОжидатьЗавершенияВыполнения(1);
		
	КонецЦикла;
	
	Если Задание.Состояние = СостояниеФоновогоЗадания.Завершено Тогда
		
		Результат = ПолучитьИзВременногоХранилища(АдресРезультата);
		
		УдалитьИзВременногоХранилища(АдресРезультата);	
		
	Иначе
		
		УдалитьИзВременногоХранилища(АдресРезультата);	
		
		Если Задание.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда
			
			ОписаниеОшибки = ?(Задание.ИнформацияОбОшибке = Неопределено,
					"Фоновое задание завершилось с неизвестнос ошибкой.",
			        ПодробноеПредставлениеОшибки(Задание.ИнформацияОбОшибке)
			);
			
		ИначеЕсли Задание.Состояние = СостояниеФоновогоЗадания.Отменено Тогда
			
			ОписаниеОшибки = "Фоновое задание было отменено.";
			
		ИначеЕсли Задание.Состояние <> СостояниеФоновогоЗадания.Завершено Тогда
			
			ОписаниеОшибки = "Неожиданное состояние фонового задания: "+Задание.Состояние+".";
			
		КонецЕсли;
		
		ВызватьИсключение ОписаниеОшибки;
		
	КонецЕсли;
		
	Возврат Результат;
	
КонецФункции

Процедура ПолучитьСтрокуСоединенияИнформационнойБазыВФоне(АдресРезультата) Экспорт
	
	Результат = СтрокаСоединенияИнформационнойБазы();
	
	ПоместитьВоВременноеХранилище(Результат, АдресРезультата);
	
КонецПроцедуры

Функция ЭтоФоновоеЗадание() Экспорт
	
	ТекущийСеансИБ = ПолучитьТекущийСеансИнформационнойБазы();
	ТекущееФЗ = ТекущийСеансИБ.ПолучитьФоновоеЗадание();
	
	Возврат (ТекущееФЗ <> Неопределено);
	
КонецФункции

#КонецОбласти
